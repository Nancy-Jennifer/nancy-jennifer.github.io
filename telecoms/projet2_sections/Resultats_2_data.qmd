---
title: "Résultats – Data (débit, latence, web/streaming)"
execute:
  echo: false
  warning: false
  message: false
---

```{r 0-deps, include=FALSE}
# Dépendances minimales (pas de gt/juicyjuice/V8/curl)
req <- c("dplyr","tidyr","stringr","forcats","ggplot2","readr","purrr")
miss <- setdiff(req, rownames(installed.packages()))
if (length(miss)) install.packages(miss, repos = "https://cloud.r-project.org")
invisible(lapply(req, function(p) suppressPackageStartupMessages(library(p, character.only = TRUE))))

# --- utilitaires de chargement auto ---
canonize_cols <- function(df) {
  # tolère différentes casses / noms proches
  nm <- names(df)
  names(df) <- stringr::str_to_lower(nm)
  # normalise quelques variantes fréquentes
  names(df) <- dplyr::recode(names(df),
                             "operateur"="operateur",
                             "opérateur"="operateur",
                             "operator" ="operateur",
                             "lieu"     ="lieu_strate",
                             "environnement"="lieu_strate",
                             "env"      ="lieu_strate",
                             "valeur"   ="valeur",
                             "value"    ="valeur",
                             .default = names(df))
  df
}

read_safely <- function(path) {
  tryCatch({
    readr::read_csv(path, show_col_types = FALSE) |> canonize_cols()
  }, error = function(e) NULL)
}

# Cherche des fichiers CSV dans plusieurs répertoires racines
roots <- c("data/clean", "data/raw", "telecoms/data", "data")
candidates <- unlist(purrr::map(roots, ~ if (dir.exists(.x)) list.files(.x, pattern="\\.csv$", full.names=TRUE) else character(0)))
candidates <- unique(candidates)

# Classe les fichiers par famille à partir du nom
is_down  <- stringr::str_detect(basename(candidates), "(?i)debit[_-]?down|download|downlink")
is_up    <- stringr::str_detect(basename(candidates), "(?i)debit[_-]?up|upload|uplink")
is_lat   <- stringr::str_detect(basename(candidates), "(?i)latence|latency|ping")

paths_down <- candidates[is_down]
paths_up   <- candidates[is_up]
paths_lat  <- candidates[is_lat]

# Lit & taggue
tbl_down <- purrr::map(paths_down, read_safely) |> purrr::compact() |> purrr::list_rbind()
if (NROW(tbl_down)) tbl_down$famille <- "debit_down"

tbl_up   <- purrr::map(paths_up,   read_safely) |> purrr::compact() |> purrr::list_rbind()
if (NROW(tbl_up))   tbl_up$famille   <- "debit_up"

tbl_lat  <- purrr::map(paths_lat,  read_safely) |> purrr::compact() |> purrr::list_rbind()
if (NROW(tbl_lat))  tbl_lat$famille  <- "latence_ms"

data_long <- dplyr::bind_rows(tbl_down, tbl_up, tbl_lat) |>
  dplyr::mutate(
    operateur  = operateur |> stringr::str_trim() |> stringr::str_to_lower(),
    lieu_strate= lieu_strate |> stringr::str_trim() |> stringr::str_to_lower(),
    famille    = famille |> stringr::str_trim() |> stringr::str_to_lower()
  ) |>
  dplyr::filter(!is.na(valeur))

# Garde-fou clair si rien n'a été trouvé
if (!NROW(data_long)) {
  stop(paste0(
    "Aucun CSV exploitable trouvé.\n",
    "- Place des CSV dans data/clean/ ou data/raw/ (ou telecoms/data/),\n",
    "- avec au minimum les colonnes: operateur, lieu_strate, valeur,\n",
    "- et des noms de fichiers contenant: 'debit_down'/'download', 'debit_up'/'upload', 'latence'/'latency'."
  ))
}
```

## Data — Débit & performance de l’expérience internet mobile

**Débit descendant / Latence / Web & Streaming** — indicateurs de fluidité (ARCEP 2024).

::: {.callout-note}
**Topline (30 s)**  
Habitat solide, mais **mobilité à renforcer** (variabilité débit & latence sur axes ferroviaires/routiers).  
La **consistency ≥ 30 Mbps** est un bon prédicteur de l’expérience web/streaming.  
Prioriser **~15–20 zones** d’optimisation ciblées en mobilité pour lisser les pics > 50 ms.
:::

### Objectif général
Évaluer la **QoS Data** autour de 3 familles : **débit descendant (p50)**, **latence (p50)**, **web/streaming** (via seuils de confort).

---

## 1) Préparation & structuration DATA

Les données sont consolidées en **table longue** standardisée : `operateur`, `lieu_strate` (`habitat`/`transport`), `famille`, `valeur`.

---

## 2) Comparaison par opérateur (p50)

```{r 2-data-kpi-core}
df <- data_long |>
  dplyr::mutate(
    operateur = stringr::str_to_title(operateur),
    env = dplyr::recode(lieu_strate, "habitat"="habitat","transport"="mobilite",
                        .default = stringr::str_to_lower(lieu_strate)),
    famille = stringr::str_to_lower(famille)
  )

kpi_core <- df |>
  dplyr::group_by(operateur, env) |>
  dplyr::summarise(
    dl_med_mbps = suppressWarnings(stats::median(valeur[famille=="debit_down"], na.rm=TRUE)),
    ul_med_mbps = suppressWarnings(stats::median(valeur[famille=="debit_up"],   na.rm=TRUE)),
    lat_med_ms  = suppressWarnings(stats::median(valeur[famille=="latence_ms"], na.rm=TRUE)),
    n_meas_down = sum(famille=="debit_down", na.rm=TRUE),
    .groups="drop"
  ) |>
  dplyr::arrange(env, dplyr::desc(dl_med_mbps))

kpi_core_tbl <- kpi_core |>
  dplyr::select(operateur, env, dl_med_mbps, ul_med_mbps, lat_med_ms, n_meas_down)

knitr::kable(
  kpi_core_tbl,
  caption = "KPI centraux DATA — médianes (p50)",
  digits = 1,
  align = "lcccc"
)
```

```{r 2-data-plot-down}
p_down <- kpi_core |>
  dplyr::mutate(env = stringr::str_to_title(env)) |>
  ggplot2::ggplot(ggplot2::aes(x = forcats::fct_reorder(operateur, dl_med_mbps),
                               y = dl_med_mbps, fill = env)) +
  ggplot2::geom_col(width = .6, position = ggplot2::position_dodge(width = .7)) +
  ggplot2::coord_flip() +
  ggplot2::facet_wrap(~ env, nrow = 1) +
  ggplot2::labs(x=NULL, y="Débit descendant p50 (Mbps)",
                title="Débit descendant — médiane (p50) par opérateur") +
  ggplot2::theme_minimal(base_size=12)
p_down
```

::: {.callout-note}
**Lecture métier**  
Très bons niveaux en **habitat** ; en **mobilité**, des chutes marquées trahissent la pression réseau (axes ferroviaires/routiers).
:::

---

## 3) Consistency — seuils de confort

```{r 2-data-consistency}
thresholds <- c(`ge_8`=8, `ge_30`=30, `ge_100`=100)

consistency_tbl <- df |>
  dplyr::filter(famille=="debit_down") |>
  dplyr::group_by(operateur, env) |>
  dplyr::summarise(
    dplyr::across(thresholds, ~ mean(valeur >= .x, na.rm=TRUE)*100, .names = "{.fn}_pct"),
    n = dplyr::n(),
    .groups = "drop"
  ) |>
  dplyr::mutate(dplyr::across(dplyr::matches("_pct$"), ~ round(.x, 1))) |>
  dplyr::arrange(env, dplyr::desc(ge_30_pct))

knitr::kable(
  consistency_tbl,
  caption = "Consistency débit descendant — part des tests au-dessus du seuil (%)",
  digits = 1
)
```

::: {.callout-important}
≥ **30 Mbps** ≈ navigation fluide + streaming HD stable.  
Les meilleurs dépassent **~80%** en habitat, certains chutent **< ~65%** en mobilité.
:::

---

## 4) Habitat vs Mobilité — hétérogénéité d’expérience

```{r 2-data-gap-env}
gap_env <- kpi_core |>
  dplyr::select(operateur, env, dl_med_mbps, lat_med_ms) |>
  tidyr::pivot_wider(names_from = env, values_from = c(dl_med_mbps, lat_med_ms)) |>
  dplyr::mutate(
    gap_down_mbps = dl_med_mbps_habitat - dl_med_mbps_mobilite,
    gap_lat_ms    = lat_med_ms_mobilite - lat_med_ms_habitat
  )

knitr::kable(
  gap_env,
  caption = "Écarts Habitat – Mobilité (p50)",
  digits = 1
)
```

```{r 2-data-plot-lat}
p_lat <- kpi_core |>
  dplyr::mutate(env = stringr::str_to_title(env)) |>
  ggplot2::ggplot(ggplot2::aes(x = forcats::fct_reorder(operateur, -lat_med_ms),
                               y = lat_med_ms, fill = env)) +
  ggplot2::geom_col(width = .6) +
  ggplot2::geom_hline(yintercept = 30, linetype = "dashed") +
  ggplot2::facet_wrap(~ env, nrow = 1) +
  ggplot2::labs(x=NULL, y="Latence médiane (ms)",
                title="Latence — médiane (p50) par opérateur (repère 30 ms)") +
  ggplot2::theme_minimal(base_size=12)
p_lat
```

---

## 5) Synthèse analytique & recommandations

| Famille KPI | Enjeu clé |
|---|---|
| Débit descendant | stables en habitat, dispersion en mobilité |
| Latence | seuil **30 ms** critique pour navigation & streaming |
| Web / Streaming | sensible aux pics de latence & au chaînage CDN |

::: {.callout-tip}
**Recommandations clés**  
- cibler les **axes transport** pour réduire les pics **> 50 ms**  
- piloter le palier **≥ 30 Mbps** comme KPI de confort (consistency)  
- optimiser l’acheminement **contenu/CDN** pour Web/Streaming
:::

```{r 2-data-exports}
dir.create("outputs/kpi", recursive = TRUE, showWarnings = FALSE)
readr::write_csv(kpi_core_tbl,    "outputs/kpi/kpi_core_data.csv")
readr::write_csv(consistency_tbl, "outputs/kpi/consistency_tbl.csv")
readr::write_csv(gap_env,         "outputs/kpi/gap_env.csv")
```
