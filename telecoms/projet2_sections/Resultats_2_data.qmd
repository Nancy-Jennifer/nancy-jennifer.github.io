---
title: "Résultats – Data (Internet mobile)"
subtitle: "Médianes p50 — DL / UL / RSRP"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: false
    code-fold: show
execute:
  echo: true
  warning: false
  message: false
---

## Résultats DATA – p50 essentiels

```{r data-p50-setup, echo=FALSE, message=FALSE, warning=FALSE}
suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(stringr)
  library(forcats); library(ggplot2); library(knitr)
})

# ================== utilitaires ==================
find_col <- function(nms, candidates){
  nls <- tolower(nms)
  for (c in candidates){
    i <- which(nls == tolower(c))
    if (length(i)) return(nms[i[1]])
  }
  # fallback: substring / grep souple
  for (c in candidates){
    i <- grep(c, nls, fixed = FALSE)
    if (length(i)) return(nms[i[1]])
  }
  return(NA_character_)
}

safe_as_num <- function(x){
  suppressWarnings(as.numeric(x))
}

plot_placeholder <- function(title_txt, subtitle_txt=""){
  ggplot() + theme_void() +
    annotate("text", x=0, y=0, label=title_txt, size=4.2) +
    labs(subtitle = subtitle_txt)
}

# ================== entrée requise ==================
HAS_DSN <- exists("data_scored_norm") && is.data.frame(data_scored_norm)

if (!HAS_DSN){
  WARNING_HTML <- TRUE
  dl_p50 <- ul_p50 <- rsrp_p50 <- tibble(operateur=character(), p50=double(), n=integer())
} else {
  # ========== mapping minimal et tolérant ==========
  dsn <- data_scored_norm
  nms <- names(dsn)

  op_col   <- find_col(nms, c("operateur","operator","op","operateur_nom","brand","provider"))
  env_col  <- find_col(nms, c("lieu_strate","environnement","env","area","zone","zone_strate"))
  ind_col  <- find_col(nms, c("indicateur","indicator","metric","mesure"))
  kpi_col  <- find_col(nms, c("kpi","metric_name","mesure_kpi","metric"))
  val_col  <- find_col(nms, c("valeur","value","measure","score","val"))

  # si une des colonnes vitales manque → pas de stop : on affichera un callout
  REQUIRED <- c(op_col, env_col, ind_col, kpi_col, val_col)
  MISSING  <- any(is.na(REQUIRED))
  WARNING_HTML <- MISSING

  # On construit un df standardisé UNIQUEMENT si on a au moins operateur/env/valeur
  if (!MISSING){
    df0 <- tibble(
      operateur   = as.character(dsn[[op_col]]),
      lieu_strate = as.character(dsn[[env_col]]),
      indicateur  = as.character(dsn[[ind_col]]),
      kpi         = as.character(dsn[[kpi_col]]),
      valeur      = safe_as_num(dsn[[val_col]])
    )

    df0 <- df0 %>%
      mutate(
        operateur = tools::toTitleCase(tolower(operateur)),
        env       = ifelse(is.na(lieu_strate),"inconnu", lieu_strate),
        indic_l   = str_to_lower(indicateur),
        kpi_l     = str_to_lower(kpi),
        fam = case_when(
          str_detect(indic_l, "download|descend|down|throughput|speed|\\bdl\\b") |
          str_detect(kpi_l,   "download|descend|down|throughput|speed|\\bdl\\b") ~ "dl",
          str_detect(indic_l, "upload|montant|uplink|up|\\bul\\b") |
          str_detect(kpi_l,   "upload|montant|uplink|up|\\bul\\b")                ~ "ul",
          str_detect(indic_l, "\\brsrp\\b") | str_detect(kpi_l, "\\brsrp\\b")     ~ "rsrp",
          TRUE ~ NA_character_
        )
      )

    # choix env : plus représenté hors 'inconnu' (sinon 'inconnu')
    env_top <- df0 %>% filter(!is.na(env), env != "inconnu") %>%
      count(env, sort = TRUE) %>% slice_head(n=1) %>% pull(env)
    if (length(env_top)==0) env_top <- "inconnu"
    assign("ENV_TOP", env_top, envir = .GlobalEnv) # utile pour le sous-titre

    MIN_N <- 50

    agg_p50 <- function(df, family){
      out <- df %>%
        filter(env == env_top, fam == family, is.finite(valeur)) %>%
        group_by(operateur) %>%
        summarise(
          p50 = suppressWarnings(stats::median(valeur, na.rm=TRUE)),
          n   = sum(!is.na(valeur)),
          .groups="drop"
        ) %>%
        mutate(p50 = ifelse(n < MIN_N, NA_real_, p50))
      if (!nrow(out)) tibble(operateur=character(), p50=double(), n=integer()) else out
    }

    dl_p50   <- agg_p50(df0, "dl")
    ul_p50   <- agg_p50(df0, "ul")
    rsrp_p50 <- agg_p50(df0, "rsrp")

    # ordre opérateurs = DL décroissant si dispo
    ord <- if (nrow(dl_p50)) dl_p50 %>% arrange(desc(p50)) %>% pull(operateur) else sort(unique(df0$operateur))
    reord <- function(d) if (nrow(d)) d %>% mutate(operateur = factor(operateur, levels = ord)) else d
    dl_p50   <- reord(dl_p50)
    ul_p50   <- reord(ul_p50)
    rsrp_p50 <- reord(rsrp_p50)

  } else {
    dl_p50 <- ul_p50 <- rsrp_p50 <- tibble(operateur=character(), p50=double(), n=integer())
    ENV_TOP <- "indéterminé"
  }
}

theme_set(theme_minimal(base_size = 13))

plot_bars <- function(dat, unit, title_txt, rsrp = FALSE){
  if (!nrow(dat) || all(is.na(dat$p50))) {
    plot_placeholder("Aucune donnée exploitable pour cette métrique\n(famille absente ou échantillon < seuil)",
                     subtitle_txt = paste("Environnement :", ENV_TOP))
  } else {
    g <- ggplot(dat, aes(x = operateur, y = p50)) +
      geom_col() +
      geom_text(aes(label = ifelse(is.na(p50), "n<seuil", sprintf("%.1f", p50))),
                vjust = -0.25, size = 3.5) +
      labs(title = title_txt,
           subtitle = paste("Environnement :", ENV_TOP, "— seuil n par opérateur = 50"),
           x = NULL, y = unit)
    if (rsrp) g <- g + geom_hline(yintercept = -100, linetype = "dashed")
    g
  }
}
```

```{r data-p50-warning, results='asis', echo=FALSE}
if (exists("WARNING_HTML") && isTRUE(WARNING_HTML)) {
  cat('
::: {.callout-warning}
**Colonnes attendues introuvables dans `data_scored_norm`.**  
Requis (au minimum) : *operateur*, *lieu_strate*, *indicateur*, *kpi*, *valeur*.

- Vérifie tes chunks EDA qui construisent `data_scored_norm`.
- Si tes noms diffèrent, reviens vers moi pour adapter le mapping.
:::
')
}
```

### Débit descendant — p50
```{r data-p50-dl, fig.width=8, fig.height=4.4}
plot_bars(dl_p50, unit = "Mb/s", title_txt = "Débit descendant — médiane p50")
```

### Débit montant — p50
```{r data-p50-ul, fig.width=8, fig.height=4.4}
plot_bars(ul_p50, unit = "Mb/s", title_txt = "Débit montant — médiane p50")
```

### RSRP — p50
```{r data-p50-rsrp, fig.width=8, fig.height=4.4}
# Rappel: en dBm, plus proche de 0 = meilleur. Ligne pointillée à -100 dBm à titre indicatif.
plot_bars(rsrp_p50, unit = "dBm (plus proche de 0 = meilleur)", title_txt = "RSRP — médiane p50", rsrp = TRUE)
```
