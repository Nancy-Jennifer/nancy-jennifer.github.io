---
title: "Résultats – Data (Internet mobile)"
subtitle: "Pass 5s/10s pondérés & radio (RSRP/RSCP) — rendu exécutif, sans code visible"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: false
    code-fold: false
execute:
  echo: false
  warning: false
  message: false
---

```{r setup, include=FALSE}
suppressPackageStartupMessages({
  library(dplyr)
  library(readr)
})

# =========================
# 0) Préparer la source
# =========================
# Principe :
# - Si data_scored_norm existe déjà -> on l'utilise.
# - Sinon, si data_scored_clean existe -> on normalise ici (codes hors plage & clamp q01–q99).
# - Dans tous les cas, on tente de sauvegarder un artefact pour les builds suivants.

build_norm_locally <- function(df_clean) {
  clamp <- function(x, lo, hi) pmin(pmax(x, lo), hi)
  df <- df_clean

  # Recode RSRP <= -141 dBm -> NA
  df <- df %>%
    mutate(valeur = ifelse(indicateur == "rsrp" & !is.na(valeur) & valeur <= -141, NA_real_, valeur))

  # Bornes q01–q99 sur RSCP/RSRP uniquement
  bounds <- df %>%
    filter(indicateur %in% c("rscp","rsrp"), !is.na(valeur)) %>%
    group_by(indicateur) %>%
    summarise(q01 = quantile(valeur, 0.01, na.rm = TRUE),
              q99 = quantile(valeur, 0.99, na.rm = TRUE), .groups = "drop")

  df_norm <- df %>%
    left_join(bounds, by = "indicateur") %>%
    mutate(valeur = ifelse(indicateur %in% c("rscp","rsrp") & !is.na(valeur),
                           clamp(valeur, q01, q99), valeur)) %>%
    select(-q01, -q99)

  df_norm
}

if (!exists("data_scored_norm")) {
  if (exists("data_scored_clean")) {
    data_scored_norm <- build_norm_locally(data_scored_clean)
  } else if (file.exists("outputs/data_scored_norm.rds")) {
    data_scored_norm <- readRDS("outputs/data_scored_norm.rds")
  }
}

# Sauvegarde d'artefact (si on a quelque chose)
if (exists("data_scored_norm")) {
  dir.create("outputs", showWarnings = FALSE, recursive = TRUE)
  saveRDS(data_scored_norm, "outputs/data_scored_norm.rds")
}

# Drapeaux de disponibilité pour piloter l'affichage
has_norm  <- exists("data_scored_norm")
has_pass5 <- has_norm && any(data_scored_norm$indicateur == "loaded_in_less_5_secondes",  na.rm = TRUE)
has_pass10<- has_norm && any(data_scored_norm$indicateur == "loaded_in_less_10_secondes", na.rm = TRUE)
has_rsrp  <- has_norm && any(data_scored_norm$indicateur == "rsrp",  na.rm = TRUE)
has_rscp  <- has_norm && any(data_scored_norm$indicateur == "rscp",  na.rm = TRUE)

# Palette sobre (base R)
pal <- c("#0097A7", "#8E44AD", "#E67E22", "#2E86C1")  # 4 opérateurs max
```

# Préparation (rappel)

Les indicateurs exploités : **pass < 5 s**, **pass < 10 s** (pondérés par *base_val*) et **RSRP/RSCP** (médianes & IQR, dBm : plus proche de 0 = meilleur).  
Les résultats sont consolidés **par opérateur**, tous environnements confondus.

::: tip
**Lecture métier.**  
- *Pass < 5 s* : expérience instantanée perçue.  
- *Pass < 10 s* : robustesse générale de chargement.  
- *RSRP/RSCP* : qualité radio sous-jacente ; viser **médiane ≥ −100 dBm** et **IQR serré**.
:::

# Pass rate < 5 secondes (pondéré)

Une latence initiale maîtrisée (< 5 s) traduit une **expérience instantanée** satisfaisante dans les contextes les plus exigeants (pics de charge, nœuds de trafic).

```{r pass5, fig.width=8.5, fig.height=4.4, fig.cap="Part des chargements < 5 s (pondérée par base_val)."}
if (has_pass5) {
  sub <- subset(data_scored_norm, indicateur == "loaded_in_less_5_secondes",
                select = c("operateur","valeur","base_val"))
  sub$operateur <- as.character(sub$operateur)
  ops <- sort(unique(sub$operateur))
  pct <- n_eff <- numeric(length(ops))

  wmean <- function(x,w) { if (all(is.na(x))) return(NA_real_); stats::weighted.mean(x, w, na.rm = TRUE) }
  for (i in seq_along(ops)) {
    s <- sub[sub$operateur == ops[i], ]
    pct[i] <- 100 * wmean(s$valeur, ifelse(is.na(s$base_val), 1, s$base_val))
    n_eff[i] <- sum(is.finite(s$valeur))
  }
  ord <- order(pct, decreasing = TRUE); ops <- ops[ord]; pct <- pct[ord]
  par(mar = c(7,4,2,1))
  bp <- barplot(pct, names.arg = ops, col = pal, ylim = c(0, max(5, pct, na.rm = TRUE) * 1.12),
                ylab = "% de succès", main = "Pass < 5 s – pondéré")
  text(bp, pct, labels = sprintf("%.1f%%", pct), pos = 3, cex = .9)
} else {
  cat("**Résultat non publié** dans cette version du livrable (données insuffisantes ou non incluses).")
}
```

::: note
**Lecture métier.** Le *pass < 5 s* reflète l’instantané client. Un écart > 5 pts devient perceptible.  
**Action.** Sécuriser les 5 s sur zones denses (gares, carrefours, centres commerciaux).
:::

# Pass rate < 10 secondes (pondéré)

À 10 s, la plupart des contenus finissent par charger ; les écarts résiduels signalent des **goulots de capacité/couverture**.

```{r pass10, fig.width=8.5, fig.height=4.4, fig.cap="Part des chargements < 10 s (pondérée par base_val)."}
if (has_pass10) {
  sub <- subset(data_scored_norm, indicateur == "loaded_in_less_10_secondes",
                select = c("operateur","valeur","base_val"))
  sub$operateur <- as.character(sub$operateur)
  ops <- sort(unique(sub$operateur))
  pct <- n_eff <- numeric(length(ops))

  wmean <- function(x,w) { if (all(is.na(x))) return(NA_real_); stats::weighted.mean(x, w, na.rm = TRUE) }
  for (i in seq_along(ops)) {
    s <- sub[sub$operateur == ops[i], ]
    pct[i] <- 100 * wmean(s$valeur, ifelse(is.na(s$base_val), 1, s$base_val))
    n_eff[i] <- sum(is.finite(s$valeur))
  }
  ord <- order(pct, decreasing = TRUE); ops <- ops[ord]; pct <- pct[ord]
  par(mar = c(7,4,2,1))
  bp <- barplot(pct, names.arg = ops, col = pal, ylim = c(0, max(5, pct, na.rm = TRUE) * 1.12),
                ylab = "% de succès", main = "Pass < 10 s – pondéré")
  text(bp, pct, labels = sprintf("%.1f%%", pct), pos = 3, cex = .9)
} else {
  cat("**Résultat non publié** dans cette version du livrable (données insuffisantes ou non incluses).")
}
```

::: note
**Cible.** > 90 % sur les axes à fort trafic (ferroviaire/routier) avec pilotage **heures pleines**.
:::

# Qualité radio — Médiane & IQR (RSRP / RSCP)

Un plan radio solide soutient la QoE data : viser **médiane ≥ −100 dBm** et **IQR serré** (dispersion faible).

```{r radio, fig.width=8.8, fig.height=5.4, fig.cap="RSRP/RSCP — médiane & IQR (écart inter-quartiles) par opérateur."}
if (has_rsrp || has_rscp) {
  do_box <- function(indic, col){
    sub <- subset(data_scored_norm, indicateur == indic, select = c("operateur","valeur"))
    sub$operateur <- as.character(sub$operateur)
    ops <- sort(unique(sub$operateur))
    med <- p25 <- p75 <- rep(NA_real_, length(ops))
    for (i in seq_along(ops)) {
      v <- sub$valeur[sub$operateur == ops[i]]
      v <- v[is.finite(v)]
      if (length(v) > 0) {
        med[i] <- as.numeric(stats::quantile(v, .5,  na.rm = TRUE))
        p25[i] <- as.numeric(stats::quantile(v, .25, na.rm = TRUE))
        p75[i] <- as.numeric(stats::quantile(v, .75, na.rm = TRUE))
      }
    }
    ord <- order(med, decreasing = FALSE)  # plus proche de 0 = meilleur
    ops <- ops[ord]; med <- med[ord]; p25 <- p25[ord]; p75 <- p75[ord]

    par(mar = c(7,4,2,1))
    plot(seq_along(ops), med, xaxt = "n", xlab = "", ylab = "dBm (plus proche de 0 = meilleur)",
         pch = 19, col = col, main = paste0(toupper(indic), " — médiane & IQR"))
    axis(1, at = seq_along(ops), labels = ops, las = 2, cex.axis = .9)
    segments(x0 = seq_along(ops), y0 = p25, x1 = seq_along(ops), y1 = p75, lwd = 6, col = adjustcolor(col, .5))
    abline(h = -100, lty = 2)
    text(seq_along(ops), med, labels = round(med, 0), pos = 3, cex = .8)
  }

  if (has_rsrp) do_box("rsrp", pal[3])
  if (has_rscp) do_box("rscp", pal[4])
} else {
  cat("**Résultats radio non publiés** dans cette version du livrable (données insuffisantes ou non incluses).")
}
```

::: note
**Actions.** Réduire les queues < −110 dBm sur les couloirs ferroviaires via **petites cellules** / réglages paramétriques.
:::

# Synthèse analytique & recommandations

- **Expérience immédiate (5 s)** : viser 85–90 % en zones denses ; traiter les poches sous-seuil via **dimensionnement PRB/layering** & **optim radio**.  
- **Robustesse (10 s)** : au-delà de 90 %, les irritants restants sont **localisés** ; plan d’actions ciblé par **corridors** (TGV/RER/autoroutes).  
- **Radio** : sécuriser une **médiane ≥ −100 dBm** et **resserrer l’IQR** ; chasse aux < −110 dBm avec boucle **mesure → optimisation → re-mesure**.

::: tip
**Conclusion.** Performances élevées mais **variabilité par contexte** (mobilité vs habitat).  
Un pilotage mensuel des **pass-rates pondérés** et des **médianes radio** aligne QoE et investissements.
:::
