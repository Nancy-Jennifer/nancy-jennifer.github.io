---
title: "Résultats – Data (Internet mobile)"
subtitle: "Pass 5s/10s pondérés & radio (RSRP/RSCP) — version sans dépendances"
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: false
    code-fold: show
execute:
  echo: true
  warning: false
  message: false
---

## Préparation (robuste, sans packages)

```{r data-setup, include=FALSE}
# Helper: normaliser les noms de colonnes en snake_case
norm_names <- function(x){
  x <- tolower(x)
  x <- iconv(x, to="ASCII//TRANSLIT")
  x <- gsub("[^a-z0-9_]+","_", x)
  x
}

# Choix d'une table compatible (contient au minimum operateur, indicateur, valeur)
pick_source <- function(){
  cand <- c("data_scored_norm","data_scored_clean","data_scored")
  env_objs <- ls()
  # ajouter tous les data.frames de l'environnement
  env_dfs <- env_objs[sapply(env_objs, function(nm) is.data.frame(get(nm, inherits = TRUE)))]
  cand <- unique(c(cand, env_dfs))
  for(nm in cand){
    obj <- tryCatch(get(nm, inherits = TRUE), error=function(e) NULL)
    if (is.data.frame(obj)){
      nms <- norm_names(names(obj))
      names(obj) <- nms
      if (all(c("operateur","indicateur","valeur") %in% nms)){
        if (!"base_val" %in% names(obj)) obj$base_val <- 1
        if (!"lieu_strate" %in% names(obj)) obj$lieu_strate <- "inconnu"
        if (!"kpi" %in% names(obj)) obj$kpi <- obj$indicateur
        # Casts
        obj$operateur  <- tools::toTitleCase(as.character(obj$operateur))
        obj$indicateur <- as.character(obj$indicateur)
        obj$kpi        <- as.character(obj$kpi)
        obj$lieu_strate<- as.character(obj$lieu_strate)
        suppressWarnings({ obj$valeur <- as.numeric(obj$valeur) })
        suppressWarnings({ obj$base_val <- as.numeric(obj$base_val) })
        return(obj)
      }
    }
  }
  return(NULL)
}

df0 <- pick_source()

# Flags présence indicateurs
has_data <- !is.null(df0) && nrow(df0) > 0
has_pass5  <- has_data && any(df0$indicateur == "loaded_in_less_5_secondes",  na.rm=TRUE)
has_pass10 <- has_data && any(df0$indicateur == "loaded_in_less_10_secondes", na.rm=TRUE)
has_rsrp   <- has_data && any(df0$indicateur == "rsrp",  na.rm=TRUE)
has_rscp   <- has_data && any(df0$indicateur == "rscp",  na.rm=TRUE)

# Weighted mean base R
wmean <- function(x,w){
  x <- suppressWarnings(as.numeric(x)); w <- suppressWarnings(as.numeric(w))
  ok <- is.finite(x) & is.finite(w) & w >= 0
  if (!any(ok)) return(NA_real_)
  sum(x[ok]*w[ok]) / sum(w[ok])
}

# Petite palette pour base R
pal <- c("#4063D8","#CB3C33","#389826","#9558B2")
```

```{r data-setup-note, echo=FALSE}
if (!has_data){
  cat("⚠️ Aucune table compatible trouvée (il faut au minimum: operateur, indicateur, valeur [+ base_val]).\n\nLe document se knit quand même — sections sautées.")
}
```

## Pass rate < 5 secondes (pondéré)

```{r pass5, fig.width=8, fig.height=4.6}
if (!has_data || !has_pass5){
  cat("Section sautée (indicateur `loaded_in_less_5_secondes` absent).\n")
} else {
  sub <- df0[df0$indicateur=="loaded_in_less_5_secondes", c("operateur","valeur","base_val")]
  # agrégation base R
  ops <- sort(unique(sub$operateur))
  pct <- numeric(length(ops)); n_eff <- pct
  for (i in seq_along(ops)){
    s <- sub[sub$operateur==ops[i], ]
    pct[i] <- 100*wmean(s$valeur, ifelse(is.na(s$base_val),1,s$base_val))
    n_eff[i] <- sum(is.finite(s$valeur))
  }
  ord <- order(pct, decreasing = TRUE); ops <- ops[ord]; pct <- pct[ord]
  oldpar <- par(no.readonly=TRUE); on.exit(par(oldpar), add=TRUE)
  par(mar=c(6,4,2,1))
  bp <- barplot(pct, names.arg = ops, las=2, col=pal[1],
                ylim=c(0, max(5, pct, na.rm=TRUE)*1.12),
                ylab="% de succès", main="Part des chargements < 5 s (pondéré)")
  text(bp, pct, labels=sprintf("%.1f%%", pct), pos=3, cex=.9)
}
```

## Pass rate < 10 secondes (pondéré)

```{r pass10, fig.width=8, fig.height=4.6}
if (!has_data || !has_pass10){
  cat("Section sautée (indicateur `loaded_in_less_10_secondes` absent).\n")
} else {
  sub <- df0[df0$indicateur=="loaded_in_less_10_secondes", c("operateur","valeur","base_val")]
  ops <- sort(unique(sub$operateur))
  pct <- numeric(length(ops)); n_eff <- pct
  for (i in seq_along(ops)){
    s <- sub[sub$operateur==ops[i], ]
    pct[i] <- 100*wmean(s$valeur, ifelse(is.na(s$base_val),1,s$base_val))
    n_eff[i] <- sum(is.finite(s$valeur))
  }
  ord <- order(pct, decreasing = TRUE); ops <- ops[ord]; pct <- pct[ord]
  oldpar <- par(no.readonly=TRUE); on.exit(par(oldpar), add=TRUE)
  par(mar=c(6,4,2,1))
  bp <- barplot(pct, names.arg = ops, las=2, col=pal[2],
                ylim=c(0, max(5, pct, na.rm=TRUE)*1.12),
                ylab="% de succès", main="Part des chargements < 10 s (pondéré)")
  text(bp, pct, labels=sprintf("%.1f%%", pct), pos=3, cex=.9)
}
```

## Qualité radio — médiane & IQR (RSRP/RSCP)

```{r radio, fig.width=8, fig.height=5.2}
if (!has_data || (!has_rsrp && !has_rscp)){
  cat("Section sautée (indicateurs `rsrp`/`rscp` absents).\n")
} else {
  do_box <- function(indic, col){
    sub <- df0[df0$indicateur==indic, c("operateur","valeur")]
    ops <- sort(unique(sub$operateur))
    med <- p25 <- p75 <- rep(NA_real_, length(ops))
    for (i in seq_along(ops)){
      v <- sub$valeur[sub$operateur==ops[i]]
      v <- v[is.finite(v)]
      if (length(v)>0){
        med[i] <- as.numeric(stats::quantile(v, .5,  na.rm=TRUE))
        p25[i] <- as.numeric(stats::quantile(v, .25, na.rm=TRUE))
        p75[i] <- as.numeric(stats::quantile(v, .75, na.rm=TRUE))
      }
    }
    ord <- order(med, decreasing = FALSE) # plus proche de 0 = meilleur
    ops <- ops[ord]; med <- med[ord]; p25 <- p25[ord]; p75 <- p75[ord]

    oldpar <- par(no.readonly=TRUE); on.exit(par(oldpar), add=TRUE)
    par(mar=c(6,4,2,1))
    plot(seq_along(ops), med, xaxt="n", xlab="", ylab="dBm (plus proche de 0 = meilleur)",
         ylim=range(c(p25,p75, -100), na.rm=TRUE)*1.0,
         pch=19, col=col, main=paste0(toupper(indic)," — médiane & IQR"))
    axis(1, at=seq_along(ops), labels=ops, las=2, cex.axis=.9)
    segments(x0=seq_along(ops), y0=p25, x1=seq_along(ops), y1=p75, lwd=6, col=adjustcolor(col, .5))
    abline(h=-100, lty=2)
    text(seq_along(ops), med, labels=round(med,0), pos=3, cex=.8)
  }

  if (has_rsrp) do_box("rsrp", pal[3])
  if (has_rscp) do_box("rscp", pal[4])
}
```

## Tableau récapitulatif (métriques clés)

```{r recap, echo=FALSE}
if (!has_data){
  cat("Section sautée (pas de données).")
} else {
  # Construire un tableau base R
  ops <- sort(unique(df0$operateur))
  res <- data.frame(operateur=ops, stringsAsFactors=FALSE)

  if (has_pass5){
    sub <- df0[df0$indicateur=="loaded_in_less_5_secondes", c("operateur","valeur","base_val")]
    res$pass5 <- sapply(ops, function(op){
      s <- sub[sub$operateur==op,]
      100*wmean(s$valeur, ifelse(is.na(s$base_val),1,s$base_val))
    })
  }
  if (has_pass10){
    sub <- df0[df0$indicateur=="loaded_in_less_10_secondes", c("operateur","valeur","base_val")]
    res$pass10 <- sapply(ops, function(op){
      s <- sub[sub$operateur==op,]
      100*wmean(s$valeur, ifelse(is.na(s$base_val),1,s$base_val))
    })
  }
  if (has_rsrp){
    sub <- df0[df0$indicateur=="rsrp", c("operateur","valeur")]
    res$rsrp_p50 <- sapply(ops, function(op){
      v <- sub$valeur[sub$operateur==op]; v <- v[is.finite(v)]
      if (length(v)) as.numeric(stats::quantile(v, .5, na.rm=TRUE)) else NA_real_
    })
  }
  if (has_rscp){
    sub <- df0[df0$indicateur=="rscp", c("operateur","valeur")]
    res$rscp_p50 <- sapply(ops, function(op){
      v <- sub$valeur[sub$operateur==op]; v <- v[is.finite(v)]
      if (length(v)) as.numeric(stats::quantile(v, .5, na.rm=TRUE)) else NA_real_
    })
  }

  # Mise en forme simple
  if ("pass5" %in% names(res))  res$pass5  <- sprintf("%.1f%%", res$pass5)
  if ("pass10"%in% names(res))  res$pass10 <- sprintf("%.1f%%", res$pass10)
  # Affichage
  if (requireNamespace("knitr", quietly=TRUE)) {
    knitr::kable(res, col.names = gsub("_", " ", names(res), fixed=TRUE))
  } else {
    print(res)
  }
}
```
