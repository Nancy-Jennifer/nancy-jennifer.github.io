---
title: "Exploration des données — QoS mobile 2024"
subtitle: "Voix & Internet mobile — France métropolitaine"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
execute:
  echo: false
  warning: false
  message: false
---

```{r setup, include=FALSE}
library(readr)
library(dplyr)
library(ggplot2)

knitr::opts_chunk$set(
  echo    = FALSE,
  message = FALSE,
  warning = FALSE
)

clean_names_local <- function(df) {
  nms <- names(df)
  nms <- trimws(nms)
  nms <- tolower(nms)
  nms <- gsub("[^[:alnum:]]+", "_", nms)
  nms <- gsub("_+", "_", nms)
  nms <- gsub("^_|_$", "", nms)
  names(df) <- nms
  df
}

operateurs_levels <- c("Orange", "SFR", "Bouygues", "Free")

standardiser_operateur <- function(df) {
  if (!"operator" %in% names(df)) return(df)
  df$operator <- as.character(df$operator)
  df$operator[df$operator == "Bouygues Telecom"] <- "Bouygues"
  df$operator <- factor(df$operator, levels = operateurs_levels)
  df
}

# Check non-verbeux : confirme la présence de colonnes clés (le rendu continue)
assert_cols <- function(df, cols, tag="") {
  missing <- setdiff(cols, names(df))
  if (length(missing) > 0) {
    message(paste0("[", tag, "] colonnes manquantes : ", paste(missing, collapse=", ")))
  }
  invisible(TRUE)
}

# Lecture tolérante : si un fichier manque, on renvoie un tibble vide (et on loggue)
read_if_exists <- function(path) {
  if (!file.exists(path)) {
    message("Fichier introuvable (skip): ", path)
    return(tibble::tibble())
  }
  readr::read_csv(path, show_col_types = FALSE)
}
```

# Cadrage & questions d’analyse

Ce document explore la **qualité de service mobile 2024** en France métropolitaine, sur deux dimensions opérationnelles :

- **Voix** : capacité à établir et maintenir un appel (fiabilité, coupures, conditions d’établissement) ;
- **Data** : confort d’usage internet (rapidité de chargement, débit disponible), en habitat et en mobilité.

Les données proviennent des campagnes de mesures terrain ARCEP. L’objectif ici est de :

- comparer les opérateurs sur des **indicateurs directement lisibles**,
- identifier les **contextes de dégradation** (habitat vs transports, zones),
- isoler les **zones à risque** pour alimenter une priorisation d’optimisation réseau.

# Données & préparation

## Chargement des fichiers (ARCEP France)

```{r load-data-fr}
# 1) Détection robuste de la racine du repo (évite les erreurs en rendu Quarto / GitHub Actions)
sentinel_rel <- file.path("data", "processed", "arcep_2024_indicateurs_globaux_clean.csv")
candidates <- c(".", "..", "../..", "../../..", "../../../..")

base_dir <- candidates[file.exists(file.path(candidates, sentinel_rel))][1]

if (is.na(base_dir)) {
  stop(
    "Impossible de localiser la racine du repo. Je ne trouve pas : ",
    sentinel_rel,
    " (testé depuis: ", paste(candidates, collapse = ", "), ")"
  )
}

# 2) Chemins
p_globaux <- file.path(base_dir, "data", "processed", "arcep_2024_indicateurs_globaux_clean.csv")
p_voix_hab <- file.path(base_dir, "data", "processed", "2024_QoS_Metropole_voix_habitations_clean.csv")
p_voix_trp <- file.path(base_dir, "data", "processed", "2024_QoS_Metropole_voix_transports_clean.csv")
p_data_hab <- file.path(base_dir, "data", "processed", "2024_QoS_Metropole_data_habitations_clean.csv")

# Data transports : on teste plusieurs variantes (selon l'export réel)
data_trans_candidates <- c(
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_data_transports_clean.csv"),
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_data_transports_clean.csv.gz"),
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_data_transports_clean.csv.zip"),
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_data_transports_clean.csv.gz.zip")
)
p_data_trp <- data_trans_candidates[file.exists(data_trans_candidates)][1]
if (is.na(p_data_trp)) {
  message("Aucun fichier Data transports trouvé. Candidats testés : ",
          paste(basename(data_trans_candidates), collapse = ", "))
  p_data_trp <- data_trans_candidates[1]
}

# 3) Lecture
globaux_clean <- read_if_exists(p_globaux) |> clean_names_local()

voix_hab <- read_if_exists(p_voix_hab) |>
  clean_names_local() |>
  standardiser_operateur()

voix_trans <- read_if_exists(p_voix_trp) |>
  clean_names_local() |>
  standardiser_operateur()

data_hab <- read_if_exists(p_data_hab) |>
  clean_names_local() |>
  standardiser_operateur()

data_trans <- read_if_exists(p_data_trp) |>
  clean_names_local() |>
  standardiser_operateur()

# 4) Checks minimaux
assert_cols(voix_hab,   c("operator"), "voix_hab")
assert_cols(voix_trans, c("operator"), "voix_trans")
assert_cols(data_hab,   c("operator"), "data_hab")
assert_cols(data_trans, c("operator"), "data_trans")

# 5) Log volumes (utile si un build replante)
sizes <- c(
  globaux_clean = nrow(globaux_clean),
  voix_hab      = nrow(voix_hab),
  voix_trans    = nrow(voix_trans),
  data_hab      = nrow(data_hab),
  data_trans    = nrow(data_trans)
)
message("Volumes chargés: ", paste(names(sizes), sizes, sep="=", collapse=" | "))
```

## Harmonisation des structures

```{r standardisation-operateurs}
voix_all <- bind_rows(
  voix_hab   |> mutate(context = "Habitations"),
  voix_trans |> mutate(context = "Transports")
)

if (!"zone" %in% names(voix_all)) voix_all$zone <- "inconnue"
voix_all$zone <- factor(voix_all$zone)

data_all <- bind_rows(
  data_hab   |> mutate(context = "Habitations"),
  data_trans |> mutate(context = "Transports")
)

if (!"zone" %in% names(data_all)) data_all$zone <- "inconnue"
data_all$zone <- factor(data_all$zone)
```

---

# Voix — fiabilité des appels

## Score Voix (0–100) par opérateur

```{r voix-kpi}
assert_cols(voix_all, c("crspa","operator","zone","context"), "voix_all")

# Si crspa n'existe pas, on évite un plantage dur et on sort proprement
if (!all(c("crspa","operator","zone","context") %in% names(voix_all))) {
  message("Voix: colonnes indispensables absentes. Vérifie le mapping des exports ARCEP (crspa/operator/zone).")
  voix_kpi_rescale <- tibble::tibble()
  kpi_voix_synthese_operateur <- tibble::tibble()
} else {
  voix_kpi_base <- voix_all |>
    filter(!is.na(crspa)) |>
    group_by(operator, zone, context) |>
    summarise(
      taux_appels_reussis = mean(crspa == 1, na.rm = TRUE),
      n                   = n(),
      .groups             = "drop"
    )

  voix_kpi_rescale <- voix_kpi_base |>
    mutate(score_voix_100 = 100 * taux_appels_reussis)

  kpi_voix_synthese_operateur <- voix_kpi_rescale |>
    group_by(operator) |>
    summarise(
      score_voix_moyen = weighted.mean(score_voix_100, w = n, na.rm = TRUE),
      n_total          = sum(n),
      .groups          = "drop"
    ) |>
    arrange(desc(score_voix_moyen))
}
```

```{r voix-kpi-table}
kpi_voix_synthese_operateur
```

**Lecture opérationnelle :**
- Score 0–100, pondéré par le volume de mesures ;
- vision directe de la fiabilité d’établissement d’appel par opérateur.

```{r voix-kpi-plot, fig.cap="Voix — score d’appels réussis (0–100) par opérateur, zone et contexte."}
if (nrow(voix_kpi_rescale) > 0) {
  ggplot(voix_kpi_rescale,
         aes(x = operator, y = score_voix_100, fill = operator)) +
    geom_col() +
    facet_grid(context ~ zone) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(
      title    = "Voix — score d’appels réussis (0–100)",
      subtitle = "Lecture croisée opérateur × zone × contexte",
      x        = NULL,
      y        = "Score Voix (0–100)"
    ) +
    guides(fill = "none") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
} else {
  message("Voix: pas de données exploitables pour tracer le graphique.")
}
```

## Zones à risque (Voix)

```{r voix-zones-risque}
if (nrow(voix_kpi_rescale) > 0) {
  voix_anomalies <- voix_kpi_rescale |>
    filter(score_voix_100 < 95) |>
    arrange(score_voix_100)
} else {
  voix_anomalies <- tibble::tibble()
}

voix_anomalies
```

**Seuils de lecture :**
- **< 90** : risque élevé pour l’expérience client (priorité de traitement) ;
- **90–95** : dégradation sensible (plan d’amélioration à 6–12 mois).

```{r voix-zones-risque-plot-hab, fig.cap="Voix — zones à risque (score < 95) — Habitations."}
if (nrow(voix_anomalies) > 0) {
  voix_anomalies_hab <- voix_anomalies |>
    dplyr::filter(context == "Habitations")

  if (nrow(voix_anomalies_hab) > 0) {
    ggplot(
      voix_anomalies_hab,
      aes(x = zone, y = score_voix_100, fill = operator)
    ) +
      geom_col(position = position_dodge(width = 0.7)) +
      scale_y_continuous(limits = c(0, 100)) +
      labs(
        title    = "Voix — zones à risque (score < 95)",
        subtitle = "Habitations — lecture par zone et opérateur",
        x        = "Zone",
        y        = "Score Voix (0–100)",
        fill     = "Opérateur"
      ) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  } else {
    message("Voix: aucune zone à risque en Habitations selon le seuil <95.")
  }
}
```

```{r voix-zones-risque-plot-trans, fig.cap="Voix — zones à risque (score < 95) — Transports."}
if (nrow(voix_anomalies) > 0) {
  voix_anomalies_trans <- voix_anomalies |>
    dplyr::filter(context == "Transports")

  if (nrow(voix_anomalies_trans) > 0) {
    ggplot(
      voix_anomalies_trans,
      aes(x = zone, y = score_voix_100, fill = operator)
    ) +
      geom_col(position = position_dodge(width = 0.7)) +
      scale_y_continuous(limits = c(0, 100)) +
      labs(
        title    = "Voix — zones à risque (score < 95)",
        subtitle = "Transports — lecture par zone et opérateur",
        x        = "Zone",
        y        = "Score Voix (0–100)",
        fill     = "Opérateur"
      ) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  } else {
    message("Voix: aucune zone à risque en Transports selon le seuil <95.")
  }
}
```

---

# Data — confort d’usage internet mobile

## KPI Data par opérateur

```{r data-kpi}
assert_cols(data_all, c("loaded_in_less_10_secondes","bitrate_dl","operator","context"), "data_all")

if (!all(c("loaded_in_less_10_secondes","bitrate_dl","operator","context") %in% names(data_all))) {
  message("Data: colonnes indispensables absentes. Vérifie le mapping (loaded_in_less_10_secondes/bitrate_dl/operator/context).")
  data_kpi_prov_operateur <- tibble::tibble()
} else {
  data_kpi_prov_operateur <- data_all |>
    group_by(context, operator) |>
    summarise(
      part_pages_10s = mean(loaded_in_less_10_secondes == 1, na.rm = TRUE),
      debit_dl_med   = median(bitrate_dl, na.rm = TRUE),
      n              = n(),
      .groups        = "drop"
    ) |>
    mutate(part_pages_10s_100 = 100 * part_pages_10s)
}

data_kpi_prov_operateur
```

```{r data-kpi-plot, fig.cap="Internet mobile — part des pages chargées en moins de 10 s, par opérateur et contexte."}
if (nrow(data_kpi_prov_operateur) > 0) {
  ggplot(data_kpi_prov_operateur,
         aes(x = operator, y = part_pages_10s_100, fill = operator)) +
    geom_col() +
    facet_wrap(~ context) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(
      title    = "Internet mobile — pages chargées en moins de 10 s",
      subtitle = "Par opérateur et par contexte",
      x        = NULL,
      y        = "Part des pages < 10 s (%)"
    ) +
    guides(fill = "none") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
} else {
  message("Data: pas de données exploitables pour tracer le graphique.")
}
```

**Lecture opérationnelle :**
- **< 10 s** : indicateur direct de confort perçu ;
- **débit médian** : proxy de capacité radio réellement disponible.

## Performance Data par zone

```{r data-zone-kpi}
if (nrow(data_all) > 0 && "zone" %in% colnames(data_all) && all(c("loaded_in_less_10_secondes","bitrate_dl","operator","context") %in% names(data_all))) {
  data_env_probe_map <- data_all |>
    group_by(context, operator, zone) |>
    summarise(
      part_pages_10s = mean(loaded_in_less_10_secondes == 1, na.rm = TRUE),
      debit_dl_med   = median(bitrate_dl, na.rm = TRUE),
      n              = n(),
      .groups        = "drop"
    ) |>
    mutate(part_pages_10s_100 = 100 * part_pages_10s)
} else {
  data_env_probe_map <- NULL
}

data_env_probe_map
```

```{r data-zone-plot-hab, fig.cap="Internet mobile — performance par zone — Habitations."}
if (!is.null(data_env_probe_map) && nrow(data_env_probe_map) > 0) {
  data_hab_zones <- data_env_probe_map |> dplyr::filter(context == "Habitations")

  if (nrow(data_hab_zones) > 0) {
    ggplot(data_hab_zones,
           aes(x = zone, y = part_pages_10s_100, fill = operator)) +
      geom_col(position = position_dodge(width = 0.7)) +
      scale_y_continuous(limits = c(0, 100)) +
      labs(
        title    = "Internet mobile — performance par zone",
        subtitle = "Habitations — part des pages < 10 s par opérateur",
        x        = "Zone",
        y        = "Part des pages < 10 s (%)",
        fill     = "Opérateur"
      ) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  } else {
    message("Data: pas de zones exploitables (Habitations).")
  }
}
```

```{r data-zone-plot-trans, fig.cap="Internet mobile — performance par zone — Transports."}
if (!is.null(data_env_probe_map) && nrow(data_env_probe_map) > 0) {
  data_trans_zones <- data_env_probe_map |> dplyr::filter(context == "Transports")

  if (nrow(data_trans_zones) > 0) {
    ggplot(data_trans_zones,
           aes(x = zone, y = part_pages_10s_100, fill = operator)) +
      geom_col(position = position_dodge(width = 0.7)) +
      scale_y_continuous(limits = c(0, 100)) +
      labs(
        title    = "Internet mobile — performance par zone",
        subtitle = "Transports — part des pages < 10 s par opérateur",
        x        = "Zone",
        y        = "Part des pages < 10 s (%)",
        fill     = "Opérateur"
      ) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  } else {
    message("Data: pas de zones exploitables (Transports).")
  }
}
```

## Micro-diagnostics (entrée plan d’action)

```{r data-micro}
if (nrow(data_kpi_prov_operateur) > 0) {
  data_micro_diag <- data_kpi_prov_operateur |>
    arrange(part_pages_10s_100) |>
    slice_head(n = 10)
} else {
  data_micro_diag <- tibble::tibble()
}

data_micro_diag
```

**Lecture opérationnelle :**
- top 10 des combinaisons **opérateur × contexte** les plus fragiles ;
- liste directement exploitable pour prioriser des actions (radio/capacité/cœur, selon le cas).

---

# Benchmark international — positionnement (indicateurs d’usage)

Cette section donne un point de repère simple : la France se situe dans une zone de **maturité numérique élevée** en usage et en équipement.  
Elle sert à contextualiser les performances terrain ARCEP (Voix/Data).

## Usage d’internet — France vs UE vs Monde

```{r itu_internet_use_data}
internet_use_itu <- tibble::tibble(
  region = factor(
    c("France", "Union européenne", "Monde"),
    levels = c("France", "Union européenne", "Monde")
  ),
  internet_use_pct = c(92, 88, 70)
)

internet_use_itu
```

```{r itu_internet_use_plot, fig.cap="Usage d’internet (% population) — France vs moyennes régionales (UIT 2024)."}
ggplot(internet_use_itu,
       aes(x = region, y = internet_use_pct)) +
  geom_col(width = 0.6) +
  geom_text(aes(label = internet_use_pct),
            vjust = -0.3, size = 4) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(
    title    = "Usage d’internet (% population)",
    subtitle = "France — Union européenne — Monde (UIT 2024)",
    x        = NULL,
    y        = "% de la population"
  )
```

## Abonnements haut-débit mobile (pour 100 habitants)

```{r itu_mbb_data}
mbb_itu <- tibble::tibble(
  region = factor(
    c("France", "Union européenne", "Monde"),
    levels = c("France", "Union européenne", "Monde")
  ),
  mbb_per_100 = c(115, 120, 95)
)

mbb_itu
```

```{r itu_mbb_plot, fig.cap="Abonnements haut-débit mobile (pour 100 habitants) — France vs moyennes régionales (UIT 2024)."}
ggplot(mbb_itu,
       aes(x = region, y = mbb_per_100)) +
  geom_col(width = 0.6) +
  geom_text(aes(label = mbb_per_100),
            vjust = -0.3, size = 4) +
  labs(
    title    = "Haut-débit mobile — abonnements pour 100 habitants",
    subtitle = "France — Union européenne — Monde (UIT 2024)",
    x        = NULL,
    y        = "Abonnements / 100 habitants"
  )
```

---

# Synthèse & recommandations

Cette exploration met en évidence :

- en **Voix**, une performance globalement élevée, avec des poches de fragilité selon **zone × contexte** ;
- en **Data**, des écarts plus sensibles entre opérateurs et des dégradations plus marquées en mobilité.

Pistes opérationnelles directement actionnables :

- **Voix** : cibler en priorité les couples *opérateur × zone* sous **90/100**, puis sécuriser la continuité sur axes de transport ;
- **Data** : fixer une cible de **pages < 10 s** et concentrer l’optimisation sur les zones où l’indicateur et le débit médian se dégradent simultanément ;
- **Pilotage** : tableau de bord simple “Habitat vs Transports”, suivi mensuel, et boucle *mesure → optimisation → re-mesure*.

[← Préparation](01_prepa_python.qmd) · [← Retour à la section Résultats](Resultats.qmd)
