---
title: "P2 – EDA (R) : Qualité de service mobile – France 2024"
subtitle: "ARCEP 2024 · ITU Facts & Figures 2024"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    df-print: paged
execute:
  echo: false
  warning: false
  message: false
---

## 1. Contexte & portée de l’analyse

Ce document présente l’analyse exploratoire de la qualité de service mobile en France métropolitaine en 2024, à partir :

- des mesures ARCEP (Voix, SMS, Web, Data, vidéo, débits, WhatsApp) ;
- des mesures détaillées par appel / session data (habitations et transports) ;
- d’un résumé des jeux de données internationaux ITU Facts & Figures 2024.

L’objectif est de :

- dresser un **profil quantitatif** de la QoS mobile (France 2024) ;
- comparer les performances selon les **opérateurs** et les **zones** (habitations vs transports) ;
- préparer le terrain pour un **benchmark international** plus détaillé (France vs standards internationaux).

---

## 2. Chargement des données & contrôle qualité

```{r}
# 2.1. Chargement des packages ----
ensure_packages <- function(pkgs) {
  repos <- getOption("repos")
  if (is.null(repos) || identical(repos["CRAN"], "@CRAN@")) {
    options(repos = c(CRAN = "https://cloud.r-project.org"))
  }
  to_install <- pkgs[!pkgs %in% installed.packages()[,"Package"]]
  if (length(to_install)) install.packages(to_install, quiet = TRUE)
  invisible(lapply(pkgs, library, character.only = TRUE))
}

ensure_packages(c(
  "readr","readxl","dplyr","tidyr","stringr","forcats",
  "ggplot2","gt","janitor","purrr","tibble","scales",
  "rlang","tidyselect"
))

theme_set(ggplot2::theme_minimal(base_size = 13))

# 2.2. Chemins (relatifs au projet Quarto) ----
base_dir   <- "."
proc_dir   <- file.path(base_dir, "data", "processed")
clean_dir  <- file.path(base_dir, "data", "clean_final")

# 2.3. Helpers robustes ----
read_csv_safe <- function(path, ...) {
  if (!file.exists(path)) return(tibble::tibble())
  tryCatch(
    readr::read_csv(path, show_col_types = FALSE, ...),
    error = function(e) tibble::tibble()
  )
}

norm_names <- function(df) {
  if (!is.data.frame(df) || nrow(df) == 0) return(df)
  df |>
    janitor::clean_names() |>
    dplyr::rename_with(\(x) x |>
      stringr::str_replace_all("[^a-z0-9]+","_") |>
      stringr::str_replace_all("_+","_") |>
      stringr::str_replace("^_|_$",""))
}

`%||%` <- function(a, b) {
  if (is.null(a) || (is.atomic(a) && length(a) == 0) || (length(a) == 1 && is.na(a))) b else a
}

first_present <- function(candidates, names_vec, default = NA_character_) {
  x <- intersect(candidates, names_vec)
  if (length(x) > 0) x[[1]] else default
}
```

```{r}
# 2.4. Fichiers utilisés ----

# ARCEP – indicateurs globaux
f_glob_clean     <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_clean.csv")
f_glob_complet   <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_complet.csv")
f_glob_simplifie <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_simplifie.csv")

# ARCEP – Voix / Data par mesure individuelle
f_voix_hab  <- file.path(proc_dir, "2024_QoS_Metropole_voix_habitations_clean.csv")
f_voix_trp  <- file.path(proc_dir, "2024_QoS_Metropole_voix_transports_clean.csv")
f_data_hab  <- file.path(proc_dir, "2024_QoS_Metropole_data_habitations_clean.csv")
f_data_trp  <- file.path(proc_dir, "2024_QoS_Metropole_data_transports_clean.csv")

# ITU – Facts & Figures (résumé)
f_itu_sum   <- file.path(clean_dir, "ITU_FactsFigures2024_summary_clean.csv")

# 2.5. Lecture + normalisation des noms de colonnes ----
arcep_glob        <- norm_names(read_csv_safe(f_glob_clean))
arcep_glob_compl  <- norm_names(read_csv_safe(f_glob_complet))
arcep_glob_simpl  <- norm_names(read_csv_safe(f_glob_simplifie))

voix_hab <- norm_names(read_csv_safe(f_voix_hab))
voix_trp <- norm_names(read_csv_safe(f_voix_trp))
data_hab <- norm_names(read_csv_safe(f_data_hab))
data_trp <- norm_names(read_csv_safe(f_data_trp))

itu_sum  <- norm_names(read_csv_safe(f_itu_sum))
```

```{r}
# 2.6. Contrôle rapide : fichiers chargés & nombre de lignes ----
qa_tbl <- tibble::tibble(
  fichier = c(
    "arcep_2024_indicateurs_globaux_clean",
    "arcep_2024_indicateurs_globaux_complet",
    "arcep_2024_indicateurs_globaux_simplifie",
    "2024_QoS_Metropole_voix_habitations_clean",
    "2024_QoS_Metropole_voix_transports_clean",
    "2024_QoS_Metropole_data_habitations_clean",
    "2024_QoS_Metropole_data_transports_clean",
    "ITU_FactsFigures2024_summary_clean"
  ),
  lignes = c(
    nrow(arcep_glob),
    nrow(arcep_glob_compl),
    nrow(arcep_glob_simpl),
    nrow(voix_hab),
    nrow(voix_trp),
    nrow(data_hab),
    nrow(data_trp),
    nrow(itu_sum)
  )
)

qa_tbl |>
  gt::gt() |>
  gt::fmt_number(columns = lignes, decimals = 0) |>
  gt::tab_header(title = "Contrôle des entrées – nombre de lignes par fichier")
```

---

## 3. Vue d’ensemble des indicateurs globaux ARCEP

Cette section exploite les indicateurs agrégés ARCEP par **service** (Voix, SMS, Web, Data, vidéo, etc.) et par **opérateur**.

```{r}
# 3.1. Passage en format long (opérateurs) ----
arcep_glob_long <- arcep_glob |>
  dplyr::filter(!is.na(service), !is.na(indicateur)) |>
  tidyr::pivot_longer(
    cols = tidyselect::all_of(c("bouygues","free","orange","sfr")),
    names_to = "operateur",
    values_to = "valeur"
  ) |>
  dplyr::mutate(
    operateur = dplyr::case_when(
      operateur == "bouygues" ~ "Bouygues Telecom",
      operateur == "free"     ~ "Free Mobile",
      operateur == "orange"   ~ "Orange",
      operateur == "sfr"      ~ "SFR",
      TRUE ~ operateur
    )
  )
```

### 3.1. Indicateurs clés – toutes zones d’habitation, tous usages

```{r}
glob_hab <- arcep_glob_long |>
  dplyr::filter(
    lieu_strate == "toutes zones d'habitation",
    situation   == "tous usages"
  )

# Vue synthétique : nombre de mesures par service / indicateur
if (nrow(glob_hab) > 0) {
  glob_hab |>
    dplyr::count(service, indicateur, sort = TRUE, name = "n_mesures") |>
    dplyr::slice_head(n = 15) |>
    gt::gt() |>
    gt::fmt_number(columns = n_mesures, decimals = 0) |>
    gt::tab_header(title = "Indicateurs les plus représentés (toutes zones d'habitation, tous usages)")
}
```

### 3.2. Voix – communications réussies & qualité perçue

```{r}
# Voix – toutes zones d'habitation, tous usages
glob_voix <- glob_hab |>
  dplyr::filter(service == "voix")

# a) Taux de communications réussies
voix_reussite <- glob_voix |>
  dplyr::filter(stringr::str_detect(indicateur, "communications réussies$"))

if (nrow(voix_reussite) > 0) {
  voix_reussite |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title = "Voix – taux de communications réussies",
      subtitle = "Toutes zones d'habitation, tous usages",
      x = NULL, y = "Taux de communications réussies"
    )
}

# b) Communications sans perturbations audibles
voix_sans_pert <- glob_voix |>
  dplyr::filter(stringr::str_detect(indicateur, "sans perturbations audibles"))

if (nrow(voix_sans_pert) > 0) {
  voix_sans_pert |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title = "Voix – communications réussies sans perturbations audibles",
      subtitle = "Toutes zones d'habitation, tous usages",
      x = NULL, y = "Taux de communications sans perturbations"
    )
}

# c) MOS moyen (qualité vocale perçue)
voix_mos <- glob_voix |>
  dplyr::filter(stringr::str_detect(indicateur, "^mos moyen$"))

if (nrow(voix_mos) > 0) {
  voix_mos |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::labs(
      title = "Voix – MOS moyen",
      subtitle = "Toutes zones d'habitation, tous usages",
      x = NULL, y = "MOS moyen"
    )
}
```

### 3.3. Web & Data – délais de chargement des pages

```{r}
glob_web <- glob_hab |>
  dplyr::filter(service == "web")

web_10s <- glob_web |>
  dplyr::filter(stringr::str_detect(indicateur, "10s"))
web_5s  <- glob_web |>
  dplyr::filter(stringr::str_detect(indicateur, "5s"))

if (nrow(web_10s) > 0) {
  web_10s |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title    = "Web – accès au site en moins de 10s",
      subtitle = "Toutes zones d'habitation, tous usages",
      x = NULL, y = "Taux de pages chargées < 10s"
    )
}

if (nrow(web_5s) > 0) {
  web_5s |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title    = "Web – accès au site en moins de 5s",
      subtitle = "Toutes zones d'habitation, tous usages",
      x = NULL, y = "Taux de pages chargées < 5s"
    )
}
```

### 3.4. Data – débits (scénario fichier 250 Mo)

```{r}
glob_dl <- arcep_glob_long |>
  dplyr::filter(service == "dl250")

if (nrow(glob_dl) > 0) {
  glob_dl |>
    dplyr::filter(lieu_strate == "toutes zones d'habitation") |>
    dplyr::group_by(operateur, indicateur) |>
    dplyr::summarise(valeur_moy = mean(valeur, na.rm = TRUE), .groups = "drop") |>
    ggplot2::ggplot(ggplot2::aes(
      x = operateur, y = valeur_moy, fill = indicateur
    )) +
    ggplot2::geom_col(position = "dodge") +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title    = "Data – distribution des débits (scénario 250 Mo)",
      subtitle = "Part des débits > 3 / 8 / 30 Mb/s – toutes zones d'habitation",
      x = NULL, y = "Part des sessions (%)",
      fill = "Seuil de débit"
    )
}
```

---

## 4. Analyse Voix détaillée (habitations & transports)

Cette section s’appuie sur les données de mesure par appel (Voix) en métropole, pour analyser :

- le **temps d’établissement d’appel** (`time_to_call`) ;
- la **qualité vocale** (MOS minimal) ;
- les différences selon les **opérateurs** et les **types de zones**.

```{r}
# 4.1. Préparation d'un jeu consolidé Voix ----
prepare_voix <- function(df, contexte) {
  if (!is.data.frame(df) || nrow(df) == 0) return(tibble::tibble())
  needed <- c("call_type","time_to_call","min_mos","zone","zone_name","operator")
  if (!all(needed %in% names(df))) return(tibble::tibble())

  df |>
    dplyr::mutate(
      contexte = contexte,
      operateur = dplyr::case_when(
        stringr::str_detect(call_type, "Orange")   ~ "Orange",
        stringr::str_detect(call_type, "SFR")      ~ "SFR",
        stringr::str_detect(call_type, "Bouygues") ~ "Bouygues Telecom",
        stringr::str_detect(call_type, "Free")     ~ "Free Mobile",
        TRUE ~ NA_character_
      ),
      time_to_call = suppressWarnings(as.numeric(time_to_call)),
      min_mos      = suppressWarnings(as.numeric(min_mos))
    ) |>
    dplyr::filter(!is.na(operateur))
}

voix_hab_prep <- prepare_voix(voix_hab, "Habitations")
voix_trp_prep <- prepare_voix(voix_trp, "Transports")

voix_all <- dplyr::bind_rows(voix_hab_prep, voix_trp_prep)
```

### 4.1. Performances moyennes par opérateur

```{r}
if (nrow(voix_all) > 0) {
  synth_voix_op <- voix_all |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(
      n_appels       = dplyr::n(),
      pct_ttc_5s     = mean(time_to_call <= 5,  na.rm = TRUE),
      pct_ttc_10s    = mean(time_to_call <= 10, na.rm = TRUE),
      mos_median     = stats::median(min_mos, na.rm = TRUE),
      .groups = "drop"
    )

  synth_voix_op |>
    dplyr::arrange(contexte, dplyr::desc(pct_ttc_5s)) |>
    gt::gt(rowname_col = "operateur") |>
    gt::fmt_number(columns = c(pct_ttc_5s, pct_ttc_10s), decimals = 3) |>
    gt::fmt_percent(columns = c(pct_ttc_5s, pct_ttc_10s), decimals = 1) |>
    gt::fmt_number(columns = mos_median, decimals = 2) |>
    gt::tab_header(title = "Voix – indicateurs de performance par opérateur et contexte")
}
```

```{r}
# Visualisation : temps d'établissement d'appel < 5s
if (nrow(voix_all) > 0) {
  voix_all |>
    dplyr::mutate(ttc_5s = time_to_call <= 5) |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(pct_ttc_5s = mean(ttc_5s, na.rm = TRUE), .groups = "drop") |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = pct_ttc_5s, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::facet_wrap(~contexte) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title = "Voix – part des appels établis en moins de 5s",
      x = NULL, y = "Part des appels (≤ 5s)"
    )
}
```

### 4.2. Zones à enjeu – qualité vocale (MOS)

```{r}
if (nrow(voix_all) > 0) {
  voix_zones <- voix_all |>
    dplyr::group_by(contexte, zone, zone_name, operateur) |>
    dplyr::summarise(
      n_appels   = dplyr::n(),
      mos_moyen  = mean(min_mos, na.rm = TRUE),
      .groups    = "drop"
    ) |>
    dplyr::filter(n_appels >= 30)  # seuil minimal de robustesse

  # Top 15 zones les plus fragiles (MOS moyen le plus faible)
  voix_zones |>
    dplyr::arrange(mos_moyen) |>
    dplyr::slice_head(n = 15) |>
    gt::gt() |>
    gt::fmt_number(columns = c(n_appels, mos_moyen), decimals = 2) |>
    gt::tab_header(title = "Voix – zones à enjeu (MOS moyen le plus faible, n_appels ≥ 30)")
}
```

---

## 5. Analyse Data détaillée (habitations & transports)

Pour la Data, l’analyse s’appuie sur les indicateurs de :

- temps de chargement des pages (`loaded_in_less_5_secondes`, `loaded_in_less_10_secondes`) ;
- perception de la qualité (`quality_correct`, `quality_perfect`) ;
- succès des transferts upload (`upload_ok`).

```{r}
prepare_data_hab <- function(df) {
  if (!is.data.frame(df) || nrow(df) == 0) return(tibble::tibble())
  needed <- c("operator","zone","zone_name",
              "loaded_in_less_5_secondes","loaded_in_less_10_secondes",
              "quality_correct","quality_perfect","upload_ok")
  if (!all(needed %in% names(df))) return(tibble::tibble())

  df |>
    dplyr::mutate(
      contexte  = "Habitations",
      operateur = dplyr::case_when(
        stringr::str_detect(operator, "Orange")   ~ "Orange",
        stringr::str_detect(operator, "SFR")      ~ "SFR",
        stringr::str_detect(operator, "Bouygues") ~ "Bouygues Telecom",
        stringr::str_detect(operator, "Free")     ~ "Free Mobile",
        TRUE ~ NA_character_
      ),
      loaded_5s  = suppressWarnings(as.numeric(loaded_in_less_5_secondes))  > 0,
      loaded_10s = suppressWarnings(as.numeric(loaded_in_less_10_secondes)) > 0,
      qual_corr  = suppressWarnings(as.numeric(quality_correct))            > 0,
      qual_perf  = suppressWarnings(as.numeric(quality_perfect))            > 0,
      upload_ok  = suppressWarnings(as.numeric(upload_ok))                  > 0
    ) |>
    dplyr::filter(!is.na(operateur))
}

prepare_data_trp <- function(df) {
  if (!is.data.frame(df) || nrow(df) == 0) return(tibble::tibble())
  needed <- c("operator","axis","axis_name",
              "loaded_in_less_5_secondes","loaded_in_less_10_secondes")
  if (!all(needed %in% names(df))) return(tibble::tibble())

  df |>
    dplyr::mutate(
      contexte  = "Transports",
      zone      = axis,
      zone_name = axis_name,
      operateur = dplyr::case_when(
        stringr::str_detect(operator, "Orange")   ~ "Orange",
        stringr::str_detect(operator, "SFR")      ~ "SFR",
        stringr::str_detect(operator, "Bouygues") ~ "Bouygues Telecom",
        stringr::str_detect(operator, "Free")     ~ "Free Mobile",
        TRUE ~ NA_character_
      ),
      loaded_5s  = suppressWarnings(as.numeric(loaded_in_less_5_secondes))  > 0,
      loaded_10s = suppressWarnings(as.numeric(loaded_in_less_10_secondes)) > 0,
      qual_corr  = NA,
      qual_perf  = NA,
      upload_ok  = NA
    ) |>
    dplyr::filter(!is.na(operateur))
}

data_hab_prep <- prepare_data_hab(data_hab)
data_trp_prep <- prepare_data_trp(data_trp)

data_all <- dplyr::bind_rows(data_hab_prep, data_trp_prep)
```

### 5.1. Performances moyennes par opérateur

```{r}
if (nrow(data_all) > 0) {
  synth_data_op <- data_all |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(
      n_sessions   = dplyr::n(),
      pct_5s       = mean(loaded_5s,  na.rm = TRUE),
      pct_10s      = mean(loaded_10s, na.rm = TRUE),
      pct_qual_corr= mean(qual_corr,  na.rm = TRUE),
      pct_qual_perf= mean(qual_perf,  na.rm = TRUE),
      pct_upload_ok= mean(upload_ok,  na.rm = TRUE),
      .groups      = "drop"
    )

  synth_data_op |>
    gt::gt(rowname_col = "operateur") |>
    gt::fmt_number(columns = n_sessions, decimals = 0) |>
    gt::fmt_percent(columns = c(pct_5s,pct_10s,pct_qual_corr,pct_qual_perf,pct_upload_ok),
                    decimals = 1) |>
    gt::tab_header(title = "Data – indicateurs de performance par opérateur et contexte")
}
```

```{r}
# Visualisation : part des pages chargées en moins de 5s
if (nrow(data_all) > 0) {
  data_all |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(pct_5s = mean(loaded_5s, na.rm = TRUE), .groups = "drop") |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = pct_5s, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::facet_wrap(~contexte) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title = "Data – part des pages chargées en moins de 5s",
      x = NULL, y = "Part des sessions (≤ 5s)"
    )
}
```

### 5.2. Zones & axes à enjeu

```{r}
if (nrow(data_all) > 0) {
  data_zones <- data_all |>
    dplyr::group_by(contexte, zone, zone_name, operateur) |>
    dplyr::summarise(
      n_sessions = dplyr::n(),
      pct_5s     = mean(loaded_5s,  na.rm = TRUE),
      pct_10s    = mean(loaded_10s, na.rm = TRUE),
      .groups    = "drop"
    ) |>
    dplyr::filter(n_sessions >= 50)

  data_zones |>
    dplyr::arrange(pct_5s) |>
    dplyr::slice_head(n = 20) |>
    gt::gt() |>
    gt::fmt_number(columns = c(n_sessions, pct_5s, pct_10s), decimals = 3) |>
    gt::fmt_percent(columns = c(pct_5s, pct_10s), decimals = 1) |>
    gt::tab_header(title = "Data – zones et axes à enjeu (part de pages ≤ 5s la plus faible)")
}
```

---

## 6. ITU Facts & Figures 2024 – synthèse des jeux de données

Les fichiers ITU Facts & Figures 2024 permettent de replacer la situation française dans un contexte international (couverture mobile, usage d’Internet, propriété d’équipements, capacité internationale, etc.).

```{r}
if (nrow(itu_sum) > 0) {
  itu_sum |>
    gt::gt() |>
    gt::fmt_number(columns = c(lignes, annees_min, annees_max, pays_regions, zones),
                   decimals = 0) |>
    gt::tab_header(title = "ITU Facts & Figures 2024 – synthèse des jeux de données disponibles")
}
```

---

## 7. Points clés (résumé exécutif)

- **Voix – niveau global élevé**, avec des taux de communications réussies et des MOS moyens très élevés, mais des **écarts subsistent entre opérateurs** et notamment entre contextes *Habitation* et *Transports*.
- **Data – expérience de navigation** : la majorité des pages se charge en moins de 10 secondes, mais l’objectif de **chargement systématique ≤ 5 secondes** n’est pas encore atteint partout, en particulier sur certains **axes de transport**.
- Les analyses par **zones / axes** mettent en évidence des **poches de fragilité**, où la qualité vocale (MOS) et/ou les temps de chargement sont inférieurs à la moyenne.
- Les jeux de données **ITU Facts & Figures 2024** offrent un cadre pour **positionner la France** par rapport à d’autres pays sur des indicateurs de couverture, d’usage et de capacité internationale.

---

## 8. Limites & pistes de prolongement

- Les indicateurs globaux ARCEP agrègent des mesures de nature différente (taux, délais, niveaux radio). Une étape complémentaire consisterait à **structurer un dictionnaire de KPI** par axe (Voix, Data, Radio) et à définir des **indices composites** par opérateur.
- Les analyses par zones / axes sont ici limitées à des **agrégations simples** (moyennes, proportions) ; elles peuvent être complétées par :
  - des **analyses de tendance** (heure, jour, saison) ;
  - des **analyses d’anomalies** (détection de valeurs atypiques par opérateur / zone).
- L’intégration détaillée des données ITU, World Bank et autres sources internationales permettra de construire un **benchmark complet** : France vs moyenne UE, OCDE, pays leaders en QoS mobile.
- Cet EDA constitue ainsi une **base technique structurée** pour alimenter :
  - un **rapport de synthèse métier**,
  - des **dashboards interactifs** (par exemple opérateur / zone / indicateur),
  - et des **recommandations opérationnelles** (priorisation des zones à optimiser).
