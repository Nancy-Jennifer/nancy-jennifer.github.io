---
title: "P2 – EDA (R) : ARCEP 2024 · ITU · World Bank"
subtitle: "France 2024 : où se situe la qualité de service mobile face aux standards internationaux ?"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    df-print: paged
execute:
  echo: false
  warning: false
  message: false
---

## 0) Préambule

```{r}
# Installation/chargement automatiques (CRAN)
ensure_packages <- function(pkgs) {
  repos <- getOption("repos")
  if (is.null(repos) || identical(repos["CRAN"], "@CRAN@")) {
    options(repos = c(CRAN = "https://cloud.r-project.org"))
  }
  to_install <- pkgs[!pkgs %in% installed.packages()[,"Package"]]
  if (length(to_install)) install.packages(to_install, quiet = TRUE)
  invisible(lapply(pkgs, library, character.only = TRUE))
}

ensure_packages(c(
  "readr","readxl","dplyr","tidyr","stringr","forcats",
  "ggplot2","gt","janitor","purrr","tibble","scales",
  "rlang","tidyselect"
))

theme_set(ggplot2::theme_minimal(base_size = 13))

# Chemins (relatifs)
base        <- "."
proc_dir    <- file.path(base, "data", "processed")
clean_final <- file.path(base, "data", "clean_final")

# Helpers sûrs/portables
read_csv_safe <- function(path, ...) {
  if (!file.exists(path)) return(tibble::tibble())
  tryCatch(readr::read_csv(path, show_col_types = FALSE, ...),
           error = function(e) tibble::tibble())
}

norm_names <- function(df) {
  if (!is.data.frame(df) || nrow(df) == 0) return(df)
  df |>
    janitor::clean_names() |>
    dplyr::rename_with(\(x) x |>
      stringr::str_replace_all("[^a-z0-9]+","_") |>
      stringr::str_replace_all("_+","_") |>
      stringr::str_replace("^_|_$",""))
}

`%||%` <- function(a, b) {
  if (is.null(a) || (is.atomic(a) && length(a) == 0) || (length(a) == 1 && is.na(a))) b else a
}

first_present <- function(candidates, names_vec, default = NA_character_) {
  x <- intersect(candidates, names_vec)
  if (length(x) > 0) x[[1]] else default
}
```

::: {.callout-note}
**Entrées attendues** : exports `*_clean.csv` générés par *01_prepa_python.qmd* dans `data/processed/` et `data/clean_final/`.  
Aucun chemin absolu ; rendu reproductible.
:::

## 1) Chargements

```{r}
# ARCEP – Globaux
f_glob_clean     <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_clean.csv")
f_glob_complet   <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_complet.csv")
f_glob_simplifie <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_simplifie.csv")

# ARCEP – Voix / Data (habitations & transports)
f_voix_hab  <- file.path(proc_dir, "2024_QoS_Metropole_voix_habitations_clean.csv")
f_voix_trp  <- file.path(proc_dir, "2024_QoS_Metropole_voix_transports_clean.csv")
f_data_hab  <- file.path(proc_dir, "2024_QoS_Metropole_data_habitations_clean.csv")
f_data_trp  <- file.path(proc_dir, "2024_QoS_Metropole_data_transports_clean.csv")

# ITU – Facts & Figures (final + summary)
f_itu_ff    <- file.path(clean_final, "ITU_FactsFigures2024_final_clean.csv")
f_itu_sum   <- file.path(clean_final, "ITU_FactsFigures2024_summary_clean.csv")

# Lecture (tolérante) + normalisation de noms
arcep_clean     <- norm_names(read_csv_safe(f_glob_clean))
arcep_complet   <- norm_names(read_csv_safe(f_glob_complet))
arcep_simplifie <- norm_names(read_csv_safe(f_glob_simplifie))

voix_hab <- norm_names(read_csv_safe(f_voix_hab))
voix_trp <- norm_names(read_csv_safe(f_voix_trp))
data_hab <- norm_names(read_csv_safe(f_data_hab))
data_trp <- norm_names(read_csv_safe(f_data_trp))

itu_ff   <- norm_names(read_csv_safe(f_itu_ff))
itu_sum  <- norm_names(read_csv_safe(f_itu_sum))
```

### Panneau QA rapide

```{r}
qa_tbl <- tibble::tibble(
  fichier = c("globaux_clean","globaux_complet","globaux_simplifie",
              "voix_habitations","voix_transports","data_habitations","data_transports",
              "itu_ff_final","itu_ff_summary"),
  lignes  = c(nrow(arcep_clean), nrow(arcep_complet), nrow(arcep_simplifie),
              nrow(voix_hab), nrow(voix_trp), nrow(data_hab), nrow(data_trp),
              nrow(itu_ff), nrow(itu_sum))
)

qa_tbl |>
  gt::gt() |>
  gt::fmt_number(columns = lignes, decimals = 0) |>
  gt::tab_header(title = "Contrôle rapide des entrées (lignes)")
```

## 2) Globaux ARCEP – aperçu

```{r}
if (nrow(arcep_clean) > 0) {
  val_col <- first_present(c("valeur","value"), names(arcep_clean), "valeur")

  df <- arcep_clean |>
    dplyr::mutate(dplyr::across(dplyr::any_of(c("annee","year")), as.integer)) |>
    dplyr::mutate(mesure = .data[[val_col]])

  top_ind <- df |>
    dplyr::count(indicateur, sort = TRUE, name = "n_mesures") |>
    dplyr::slice_head(n = 10)

  top_ind |>
    gt::gt() |>
    gt::fmt_number(columns = n_mesures, decimals = 0) |>
    gt::tab_header(title = "Indicateurs les plus présents (Top 10)")

  df |>
    dplyr::filter(!is.na(operateur), !is.na(mesure)) |>
    dplyr::group_by(operateur) |>
    dplyr::summarise(n = dplyr::n(), moyenne = mean(mesure, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(moyenne)) |>
    dplyr::slice_head(n = 10) |>
    ggplot2::ggplot(ggplot2::aes(x = reorder(operateur, moyenne), y = moyenne)) +
    ggplot2::geom_col() +
    ggplot2::coord_flip() +
    ggplot2::labs(x = NULL, y = "Moyenne (toutes mesures)", title = "Comparatif opérateurs (globaux)")
}
```

## 3) Voix – normalisation robuste & zones à risque (si données disponibles)

```{r}
# Classification souple des indicateurs Voix
classify_kpi <- function(s){
  s <- tolower(s %||% "")
  dplyr::case_when(
    stringr::str_detect(s, "delai|délai|setup|etablissement|établissement|time_to_call") ~ "delai_etablissement_appels",
    stringr::str_detect(s, "coupure|drop|fail|échec|echec|non[ -]?reuss|non[ -]?réuss")   ~ "taux_echec_appels",
    stringr::str_detect(s, "reuss|réuss|communic")                                       ~ "taux_reussite_appels",
    TRUE ~ "autre"
  )
}

bind_voix <- function(df){
  if (nrow(df) == 0) return(tibble::tibble())

  # garantir indicateur
  if (!"indicateur" %in% names(df)) df$indicateur <- NA_character_

  # colonne valeur brute
  val <- first_present(c("valeur","value"), names(df), NA_character_)
  if (is.na(val)) return(tibble::tibble())

  # colonnes opérateurs étalées possibles
  ops <- intersect(c("bouygues","free","orange","sfr","moyenne"), names(df))
  if (length(ops) > 0) {
    df <- df |>
      tidyr::pivot_longer(tidyselect::all_of(ops), names_to = "operateur", values_to = val)
  }

  # base_val si absente
  if (!"base_val" %in% names(df)) df$base_val <- 1

  df |>
    dplyr::mutate(indicateur = dplyr::coalesce(indicateur, "")) |>
    dplyr::mutate(kpi = classify_kpi(indicateur)) |>
    dplyr::filter(kpi != "autre") |>
    dplyr::mutate(
      dplyr::across(dplyr::any_of(c("annee","year")), as.integer),
      dplyr::across(tidyselect::all_of(val), ~ suppressWarnings(as.numeric(.x))),
      base_val = suppressWarnings(as.numeric(base_val))
    ) |>
    dplyr::rename(valeur = tidyselect::all_of(val))
}

voix_raw <- dplyr::bind_rows(bind_voix(voix_hab), bind_voix(voix_trp))

# Si on n'a pas au moins kpi + valeur, on arrête proprement la section Voix
if (nrow(voix_raw) == 0 || !"valeur" %in% names(voix_raw) || !"kpi" %in% names(voix_raw)) {
  voix_scored <- tibble::tibble()
  voix_kpi    <- tibble::tibble()
} else {

  rescale_01 <- function(x){
    if (all(is.na(x))) return(x)
    mx <- suppressWarnings(max(x, na.rm = TRUE))
    if (is.finite(mx) && mx > 1.5) x/100 else x
  }

  voix_scored <- voix_raw |>
    dplyr::mutate(
      valeur_reussite = dplyr::if_else(kpi == "taux_reussite_appels", rescale_01(valeur), NA_real_),
      valeur_echec    = dplyr::if_else(kpi == "taux_echec_appels",    rescale_01(valeur), NA_real_),
      valeur_delai    = dplyr::if_else(kpi == "delai_etablissement_appels", suppressWarnings(as.numeric(valeur)), NA_real_)
    )

  loc_col <- first_present(c("lieu_strate","zone","region"), names(voix_scored), NA_character_)

  voix_kpi <- voix_scored |>
    dplyr::mutate(poids = dplyr::if_else(is.na(base_val) | base_val <= 0, 1, base_val))

  if (!is.na(loc_col)) {
    voix_kpi <- voix_kpi |>
      dplyr::group_by(operateur, .data[[loc_col]], kpi) |>
      dplyr::summarise(
        p = dplyr::if_else(kpi == "delai_etablissement_appels",
                  mean(valeur_delai, na.rm = TRUE),
                  sum(dplyr::coalesce(valeur_reussite, valeur_echec, 0) * poids, na.rm = TRUE) /
                  sum(poids, na.rm = TRUE)),
        .groups = "drop"
      )
  } else {
    voix_kpi <- voix_kpi |>
      dplyr::group_by(operateur, kpi) |>
      dplyr::summarise(
        p = dplyr::if_else(kpi == "delai_etablissement_appels",
                  mean(valeur_delai, na.rm = TRUE),
                  sum(dplyr::coalesce(valeur_reussite, valeur_echec, 0) * poids, na.rm = TRUE) /
                  sum(poids, na.rm = TRUE)),
        .groups = "drop"
      )
  }

  # Classement opérateurs – réussite moyenne
  if (nrow(voix_kpi) > 0) {
    df_rank <- voix_kpi |>
      dplyr::filter(kpi == "taux_reussite_appels") |>
      dplyr::group_by(operateur) |>
      dplyr::summarise(score = mean(p, na.rm = TRUE), .groups = "drop")
    if (nrow(df_rank) > 0) {
      df_rank |>
        dplyr::mutate(operateur = forcats::fct_reorder(operateur, score)) |>
        ggplot2::ggplot(ggplot2::aes(operateur, score)) +
        ggplot2::geom_col() + ggplot2::coord_flip() +
        ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
        ggplot2::labs(x = NULL, y = "Taux de réussite moyen", title = "Voix — classement opérateurs (moyenne)")
    }
  }

  # Zones à risque (si localisation dispo)
  if (!is.na(loc_col) && nrow(voix_scored) > 0) {
    seuil_r <- 0.95; seuil_e <- 0.02
    voix_flags <- voix_scored |>
      dplyr::transmute(operateur, loc = .data[[loc_col]],
                       ok   = valeur_reussite,
                       fail = valeur_echec,
                       poids = dplyr::if_else(is.na(base_val) | base_val <= 0, 1, base_val)) |>
      dplyr::group_by(operateur, loc) |>
      dplyr::summarise(p_ok = sum(ok*poids, na.rm=TRUE)/sum(poids,na.rm=TRUE),
                       p_f  = sum(fail*poids, na.rm=TRUE)/sum(poids,na.rm=TRUE),
                       .groups="drop") |>
      dplyr::mutate(flag = (is.finite(p_ok) & p_ok < seuil_r) | (is.finite(p_f) & p_f > seuil_e))

    if (nrow(voix_flags) > 0) {
      voix_flags %>%
        dplyr::filter(flag) %>%
        dplyr::count(loc, sort = TRUE, name = "nb_alertes") %>%
        dplyr::slice_head(n = 15) %>%
        ggplot2::ggplot(ggplot2::aes(x = reorder(loc, nb_alertes), y = nb_alertes)) +
        ggplot2::geom_col() + ggplot2::coord_flip() +
        ggplot2::labs(x = NULL, y = "Nombre d'alertes", title = "Voix — Top 15 zones à risque")
    }
  }
}
```

## 4) Data – comparatifs opérateurs

```{r}
plot_perf <- function(df, titre){
  if (nrow(df) == 0) return(NULL)
  val <- first_present(c("valeur","value"), names(df), NA_character_)
  if (is.na(val)) return(NULL)

  df |>
    dplyr::filter(!is.na(operateur), !is.na(.data[[val]])) |>
    dplyr::group_by(operateur) |>
    dplyr::summarise(moy = mean(.data[[val]], na.rm = TRUE), .groups = "drop") |>
    dplyr::mutate(operateur = forcats::fct_reorder(operateur, moy)) |>
    ggplot2::ggplot(ggplot2::aes(operateur, moy)) +
    ggplot2::geom_col() + ggplot2::coord_flip() +
    ggplot2::labs(x = NULL, y = "Moyenne indicateur", title = titre)
}

data_hab_plot <- plot_perf(data_hab, "Data – zones habitées : classement opérateurs")
data_trp_plot <- plot_perf(data_trp, "Data – transports : classement opérateurs")

data_hab_plot
data_trp_plot
```

## 5) ITU – Facts & Figures (aperçu)

```{r}
if (nrow(itu_ff) > 0) {
  itu_ff |>
    dplyr::slice_head(n = 12) |>
    gt::gt() |>
    gt::tab_header(title = "ITU – Facts & Figures : aperçu (12 lignes)")
}
if (nrow(itu_sum) > 0) {
  itu_sum |>
    gt::gt() |>
    gt::tab_header(title = "ITU – Facts & Figures : résumé")
}
```

## 6) Points clés

```{r}
tibble::tibble(
  axe   = c("Robustesse","Portabilité","Lecture"),
  point = c("Lecture sûre + normalisation colonnes + EDA non bloquante",
            "Chemins relatifs, aucune dépendance locale",
            "Classements opérateurs, zones à risque (si données disponibles), aperçus ITU")
) |>
  gt::gt() |>
  gt::tab_header(title = "Synthèse EDA – points clés")
```

## 7) Limites & pistes

- Les indicateurs ARCEP recouvrent des natures différentes (taux, délais, radio) : la comparaison nécessite des sous-ensembles homogènes et, idéalement, un **mapping indicateur → catégorie**.
- Pour la **lecture métier**, construire des **KPI composites** par axe (Voix disponibilité, Data performance, Radio qualité), avec seuils cibles.
- Intégrer un **contrôle d’anomalies** (z-scores / IQR) pour repérer des valeurs atypiques par opérateur/zone.
