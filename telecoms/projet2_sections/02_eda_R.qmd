---
title: "Exploration des données — QoS mobile 2024"
subtitle: "Voix & Internet mobile — France métropolitaine"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
execute:
  echo: false
  warning: false
  message: false
---

```{r setup, include=FALSE}
library(readr)
library(dplyr)
library(ggplot2)

knitr::opts_chunk$set(
  echo    = FALSE,
  message = FALSE,
  warning = FALSE
)

clean_names_local <- function(df) {
  nms <- names(df)
  nms <- trimws(nms)
  nms <- tolower(nms)
  nms <- gsub("[^[:alnum:]]+", "_", nms)
  nms <- gsub("_+", "_", nms)
  nms <- gsub("^_|_$", "", nms)
  names(df) <- nms
  df
}

operateurs_levels <- c("Orange", "SFR", "Bouygues", "Free")

standardiser_operateur <- function(df) {
  if (!"operator" %in% names(df)) return(df)
  df$operator <- as.character(df$operator)
  df$operator[df$operator == "Bouygues Telecom"] <- "Bouygues"
  df$operator <- factor(df$operator, levels = operateurs_levels)
  df
}

# IMPORTANT :
# 02_eda_R.qmd est dans "telecoms/projet2_sections"
# Le dossier "data" est à la racine du repo
# → remonter 2 niveaux
base_dir <- "../.."

# Check non-verbeux : confirme la présence de colonnes clés (sinon le rendu continue, mais tu sais quoi mapper)
assert_cols <- function(df, cols, tag="") {
  missing <- setdiff(cols, names(df))
  if (length(missing) > 0) {
    message(paste0("[", tag, "] colonnes manquantes : ", paste(missing, collapse=", ")))
  }
  invisible(TRUE)
}
```

# Cadrage & questions d’analyse

Ce document explore la **qualité de service mobile 2024** en France métropolitaine, sur deux dimensions opérationnelles :

- **Voix** : capacité à établir et maintenir un appel (fiabilité, coupures, conditions d’établissement) ;
- **Data** : confort d’usage internet (rapidité de chargement, débit disponible), en habitat et en mobilité.

Les données proviennent des campagnes de mesures terrain ARCEP. L’objectif ici est de :

- comparer les opérateurs sur des **indicateurs directement lisibles**,
- identifier les **contextes de dégradation** (habitat vs transports, zones),
- isoler les **zones à risque** pour alimenter une priorisation d’optimisation réseau.

# Données & préparation

## Chargement des fichiers (ARCEP France)

```{r load-data-fr}
globaux_clean <- read_csv(
  file.path(base_dir, "data", "processed", "arcep_2024_indicateurs_globaux_clean.csv")
) |>
  clean_names_local()

voix_hab <- read_csv(
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_voix_habitations_clean.csv")
) |>
  clean_names_local() |>
  standardiser_operateur()

voix_trans <- read_csv(
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_voix_transports_clean.csv")
) |>
  clean_names_local() |>
  standardiser_operateur()

data_hab <- read_csv(
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_data_habitations_clean.csv")
) |>
  clean_names_local() |>
  standardiser_operateur()

# Correction : fichier attendu côté pipeline Python = .csv (pas .gz.zip)
data_trans <- read_csv(
  file.path(base_dir, "data", "processed", "2024_QoS_Metropole_data_transports_clean.csv")
) |>
  clean_names_local() |>
  standardiser_operateur()

# Checks minimaux (si une colonne manque, un message s'affiche au build)
assert_cols(voix_hab,  c("operator"), "voix_hab")
assert_cols(voix_trans,c("operator"), "voix_trans")
assert_cols(data_hab,  c("operator"), "data_hab")
assert_cols(data_trans,c("operator"), "data_trans")
```

## Harmonisation des structures

```{r standardisation-operateurs}
voix_all <- bind_rows(
  voix_hab  |> mutate(context = "Habitations"),
  voix_trans |> mutate(context = "Transports")
)

if (!"zone" %in% names(voix_all)) voix_all$zone <- "inconnue"
voix_all$zone <- factor(voix_all$zone)

data_all <- bind_rows(
  data_hab  |> mutate(context = "Habitations"),
  data_trans |> mutate(context = "Transports")
)

if (!"zone" %in% names(data_all)) data_all$zone <- "inconnue"
data_all$zone <- factor(data_all$zone)
```

---

# Voix — fiabilité des appels

## Score Voix (0–100) par opérateur

```{r voix-kpi}
# crspa : indicateur binaire (1 = appel réussi, 0 = échec) dans les exports ARCEP nettoyés
assert_cols(voix_all, c("crspa","operator","zone","context"), "voix_all")

voix_kpi_base <- voix_all |>
  filter(!is.na(crspa)) |>
  group_by(operator, zone, context) |>
  summarise(
    taux_appels_reussis = mean(crspa == 1, na.rm = TRUE),
    n                   = n(),
    .groups             = "drop"
  )

voix_kpi_rescale <- voix_kpi_base |>
  mutate(score_voix_100 = 100 * taux_appels_reussis)

kpi_voix_synthese_operateur <- voix_kpi_rescale |>
  group_by(operator) |>
  summarise(
    score_voix_moyen = weighted.mean(score_voix_100, w = n, na.rm = TRUE),
    n_total          = sum(n),
    .groups          = "drop"
  ) |>
  arrange(desc(score_voix_moyen))
```

```{r voix-kpi-table}
kpi_voix_synthese_operateur
```

**Lecture opérationnelle :**
- Score 0–100, pondéré par le volume de mesures ;
- vision directe de la fiabilité d’établissement d’appel par opérateur.

```{r voix-kpi-plot, fig.cap="Voix — score d’appels réussis (0–100) par opérateur, zone et contexte."}
ggplot(voix_kpi_rescale,
       aes(x = operator, y = score_voix_100, fill = operator)) +
  geom_col() +
  facet_grid(context ~ zone) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(
    title    = "Voix — score d’appels réussis (0–100)",
    subtitle = "Lecture croisée opérateur × zone × contexte",
    x        = NULL,
    y        = "Score Voix (0–100)"
  ) +
  guides(fill = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Zones à risque (Voix)

```{r voix-zones-risque}
voix_anomalies <- voix_kpi_rescale |>
  filter(score_voix_100 < 95) |>
  arrange(score_voix_100)

voix_anomalies
```

**Seuils de lecture :**
- **< 90** : risque élevé pour l’expérience client (priorité de traitement) ;
- **90–95** : dégradation sensible (plan d’amélioration à 6–12 mois).

```{r voix-zones-risque-plot-hab, fig.cap="Voix — zones à risque (score < 95) — Habitations."}
voix_anomalies_hab <- voix_anomalies |>
  dplyr::filter(context == "Habitations")

if (nrow(voix_anomalies_hab) > 0) {
  ggplot(
    voix_anomalies_hab,
    aes(x = zone, y = score_voix_100, fill = operator)
  ) +
    geom_col(position = position_dodge(width = 0.7)) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(
      title    = "Voix — zones à risque (score < 95)",
      subtitle = "Habitations — lecture par zone et opérateur",
      x        = "Zone",
      y        = "Score Voix (0–100)",
      fill     = "Opérateur"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
```

```{r voix-zones-risque-plot-trans, fig.cap="Voix — zones à risque (score < 95) — Transports."}
voix_anomalies_trans <- voix_anomalies |>
  dplyr::filter(context == "Transports")

if (nrow(voix_anomalies_trans) > 0) {
  ggplot(
    voix_anomalies_trans,
    aes(x = zone, y = score_voix_100, fill = operator)
  ) +
    geom_col(position = position_dodge(width = 0.7)) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(
      title    = "Voix — zones à risque (score < 95)",
      subtitle = "Transports — lecture par zone et opérateur",
      x        = "Zone",
      y        = "Score Voix (0–100)",
      fill     = "Opérateur"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
```

---

# Data — confort d’usage internet mobile

## KPI Data par opérateur

```{r data-kpi}
# loaded_in_less_10_secondes : binaire (1 = page chargée en < 10 s)
# bitrate_dl : débit descendant (Mbit/s)
assert_cols(data_all, c("loaded_in_less_10_secondes","bitrate_dl","operator","context"), "data_all")

data_kpi_prov_operateur <- data_all |>
  group_by(context, operator) |>
  summarise(
    part_pages_10s = mean(loaded_in_less_10_secondes == 1, na.rm = TRUE),
    debit_dl_med   = median(bitrate_dl, na.rm = TRUE),
    n              = n(),
    .groups        = "drop"
  ) |>
  mutate(part_pages_10s_100 = 100 * part_pages_10s)

data_kpi_prov_operateur
```

```{r data-kpi-plot, fig.cap="Internet mobile — part des pages chargées en moins de 10 s, par opérateur et contexte."}
ggplot(data_kpi_prov_operateur,
       aes(x = operator, y = part_pages_10s_100, fill = operator)) +
  geom_col() +
  facet_wrap(~ context) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(
    title    = "Internet mobile — pages chargées en moins de 10 s",
    subtitle = "Par opérateur et par contexte",
    x        = NULL,
    y        = "Part des pages < 10 s (%)"
  ) +
  guides(fill = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**Lecture opérationnelle :**
- **< 10 s** : indicateur direct de confort perçu ;
- **débit médian** : proxy de capacité radio réellement disponible.

## Performance Data par zone

```{r data-zone-kpi}
if ("zone" %in% colnames(data_all)) {
  data_env_probe_map <- data_all |>
    group_by(context, operator, zone) |>
    summarise(
      part_pages_10s = mean(loaded_in_less_10_secondes == 1, na.rm = TRUE),
      debit_dl_med   = median(bitrate_dl, na.rm = TRUE),
      n              = n(),
      .groups        = "drop"
    ) |>
    mutate(part_pages_10s_100 = 100 * part_pages_10s)
} else {
  data_env_probe_map <- NULL
}

data_env_probe_map
```

```{r data-zone-plot-hab, fig.cap="Internet mobile — performance par zone — Habitations."}
if (!is.null(data_env_probe_map) && nrow(data_env_probe_map) > 0) {
  data_hab_zones <- data_env_probe_map |> dplyr::filter(context == "Habitations")

  if (nrow(data_hab_zones) > 0) {
    ggplot(data_hab_zones,
           aes(x = zone, y = part_pages_10s_100, fill = operator)) +
      geom_col(position = position_dodge(width = 0.7)) +
      scale_y_continuous(limits = c(0, 100)) +
      labs(
        title    = "Internet mobile — performance par zone",
        subtitle = "Habitations — part des pages < 10 s par opérateur",
        x        = "Zone",
        y        = "Part des pages < 10 s (%)",
        fill     = "Opérateur"
      ) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  }
}
```

```{r data-zone-plot-trans, fig.cap="Internet mobile — performance par zone — Transports."}
if (!is.null(data_env_probe_map) && nrow(data_env_probe_map) > 0) {
  data_trans_zones <- data_env_probe_map |> dplyr::filter(context == "Transports")

  if (nrow(data_trans_zones) > 0) {
    ggplot(data_trans_zones,
           aes(x = zone, y = part_pages_10s_100, fill = operator)) +
      geom_col(position = position_dodge(width = 0.7)) +
      scale_y_continuous(limits = c(0, 100)) +
      labs(
        title    = "Internet mobile — performance par zone",
        subtitle = "Transports — part des pages < 10 s par opérateur",
        x        = "Zone",
        y        = "Part des pages < 10 s (%)",
        fill     = "Opérateur"
      ) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  }
}
```

## Micro-diagnostics (entrée plan d’action)

```{r data-micro}
data_micro_diag <- data_kpi_prov_operateur |>
  arrange(part_pages_10s_100) |>
  slice_head(n = 10)

data_micro_diag
```

**Lecture opérationnelle :**
- top 10 des combinaisons **opérateur × contexte** les plus fragiles ;
- liste directement exploitable pour prioriser des actions (radio/capacité/cœur, selon le cas).

---

# Benchmark international — positionnement (indicateurs d’usage)

Cette section donne un point de repère simple : la France se situe dans une zone de **maturité numérique élevée** en usage et en équipement.  
Elle sert à contextualiser les performances terrain ARCEP (Voix/Data).

## Usage d’internet — France vs UE vs Monde

```{r itu_internet_use_data}
internet_use_itu <- tibble::tibble(
  region = factor(
    c("France", "Union européenne", "Monde"),
    levels = c("France", "Union européenne", "Monde")
  ),
  internet_use_pct = c(92, 88, 70)
)

internet_use_itu
```

```{r itu_internet_use_plot, fig.cap="Usage d’internet (% population) — France vs moyennes régionales (UIT 2024)."}
ggplot(internet_use_itu,
       aes(x = region, y = internet_use_pct)) +
  geom_col(width = 0.6) +
  geom_text(aes(label = internet_use_pct),
            vjust = -0.3, size = 4) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(
    title    = "Usage d’internet (% population)",
    subtitle = "France — Union européenne — Monde (UIT 2024)",
    x        = NULL,
    y        = "% de la population"
  )
```

## Abonnements haut-débit mobile (pour 100 habitants)

```{r itu_mbb_data}
mbb_itu <- tibble::tibble(
  region = factor(
    c("France", "Union européenne", "Monde"),
    levels = c("France", "Union européenne", "Monde")
  ),
  mbb_per_100 = c(115, 120, 95)
)

mbb_itu
```

```{r itu_mbb_plot, fig.cap="Abonnements haut-débit mobile (pour 100 habitants) — France vs moyennes régionales (UIT 2024)."}
ggplot(mbb_itu,
       aes(x = region, y = mbb_per_100)) +
  geom_col(width = 0.6) +
  geom_text(aes(label = mbb_per_100),
            vjust = -0.3, size = 4) +
  labs(
    title    = "Haut-débit mobile — abonnements pour 100 habitants",
    subtitle = "France — Union européenne — Monde (UIT 2024)",
    x        = NULL,
    y        = "Abonnements / 100 habitants"
  )
```

---

# Synthèse & recommandations

Cette exploration met en évidence :

- en **Voix**, une performance globalement élevée, avec des poches de fragilité selon **zone × contexte** ;
- en **Data**, des écarts plus sensibles entre opérateurs et des dégradations plus marquées en mobilité.

Pistes opérationnelles directement actionnables :

- **Voix** : cibler en priorité les couples *opérateur × zone* sous **90/100**, puis sécuriser la continuité sur axes de transport ;
- **Data** : fixer une cible de **pages < 10 s** et concentrer l’optimisation sur les zones où l’indicateur et le débit médian se dégradent simultanément ;
- **Pilotage** : tableau de bord simple “Habitat vs Transports”, suivi mensuel, et boucle *mesure → optimisation → re-mesure*.

[← Préparation](01_prepa_python.qmd) · [← Retour à la section Résultats](Resultats.qmd)
