---
title: "P2 – EDA (R) : Qualité de service mobile – France 2024"
subtitle: "ARCEP 2024 · ITU Facts & Figures 2024"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    df-print: paged
execute:
  echo: false
  warning: false
  message: false
---

## 1. Contexte & périmètre

Ce document présente l’exploration des données de qualité de service mobile en France métropolitaine (ARCEP 2024), complétées par un résumé des jeux ITU Facts & Figures 2024.

Les objectifs de cette EDA sont :

- décrire les principaux indicateurs de QoS mobile (Voix, Web, Data) par opérateur ;
- analyser quelques contrastes entre **habitations** et **axes de transport** ;
- préparer un socle robuste pour la suite du projet (construction d’indicateurs synthétiques et benchmark international).

---

## 2. Chargement des données et contrôles de base

```{r}
# 2.1. Installation / chargement des packages ----
ensure_packages <- function(pkgs) {
  repos <- getOption("repos")
  if (is.null(repos) || identical(repos["CRAN"], "@CRAN@")) {
    options(repos = c(CRAN = "https://cloud.r-project.org"))
  }
  to_install <- pkgs[!pkgs %in% installed.packages()[,"Package"]]
  if (length(to_install)) install.packages(to_install, quiet = TRUE)
  invisible(lapply(pkgs, library, character.only = TRUE))
}

ensure_packages(c(
  "readr","dplyr","tidyr","stringr","forcats",
  "ggplot2","gt","janitor","tibble","scales",
  "rlang","tidyselect"
))

theme_set(ggplot2::theme_minimal(base_size = 13))

# 2.2. Fonctions utilitaires ----
read_csv_safe <- function(path, ...) {
  if (!file.exists(path)) return(tibble::tibble())
  tryCatch(
    readr::read_csv(path, show_col_types = FALSE, ...),
    error = function(e) tibble::tibble()
  )
}

norm_names <- function(df) {
  if (!is.data.frame(df) || nrow(df) == 0) return(df)
  df |>
    janitor::clean_names() |>
    dplyr::rename_with(\(x) x |>
      stringr::str_replace_all("[^a-z0-9]+","_") |>
      stringr::str_replace_all("_+","_") |>
      stringr::str_replace("^_|_$",""))
}

`%||%` <- function(a, b) {
  if (is.null(a) || (is.atomic(a) && length(a) == 0) || (length(a) == 1 && is.na(a))) b else a
}

first_present <- function(candidates, names_vec, default = NA_character_) {
  x <- intersect(candidates, names_vec)
  if (length(x) > 0) x[[1]] else default
}

# 2.3. Garde-fou : exécuter une analyse sans casser le rendu ----
safe_run <- function(code) {
  tryCatch(code, error = function(e) { NULL })
}
```

```{r}
# 2.4. Chemins de fichiers ----
base_dir  <- "."
proc_dir  <- file.path(base_dir, "data", "processed")
clean_dir <- file.path(base_dir, "data", "clean_final")

# ARCEP – globaux
f_glob_clean     <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_clean.csv")
f_glob_complet   <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_complet.csv")
f_glob_simplifie <- file.path(proc_dir, "arcep_2024_indicateurs_globaux_simplifie.csv")

# ARCEP – Voix / Data détaillés
f_voix_hab  <- file.path(proc_dir, "2024_QoS_Metropole_voix_habitations_clean.csv")
f_voix_trp  <- file.path(proc_dir, "2024_QoS_Metropole_voix_transports_clean.csv")
f_data_hab  <- file.path(proc_dir, "2024_QoS_Metropole_data_habitations_clean.csv")
f_data_trp  <- file.path(proc_dir, "2024_QoS_Metropole_data_transports_clean.csv")

# ITU – résumé
f_itu_sum   <- file.path(clean_dir, "ITU_FactsFigures2024_summary_clean.csv")

# 2.5. Lecture + normalisation ----
arcep_glob        <- norm_names(read_csv_safe(f_glob_clean))
arcep_glob_compl  <- norm_names(read_csv_safe(f_glob_complet))
arcep_glob_simpl  <- norm_names(read_csv_safe(f_glob_simplifie))

voix_hab <- norm_names(read_csv_safe(f_voix_hab))
voix_trp <- norm_names(read_csv_safe(f_voix_trp))
data_hab <- norm_names(read_csv_safe(f_data_hab))
data_trp <- norm_names(read_csv_safe(f_data_trp))

itu_sum  <- norm_names(read_csv_safe(f_itu_sum))
```

```{r}
# 2.6. Contrôle de base : nombre de lignes par fichier ----
qa_tbl <- tibble::tibble(
  fichier = c(
    "arcep_2024_indicateurs_globaux_clean",
    "arcep_2024_indicateurs_globaux_complet",
    "arcep_2024_indicateurs_globaux_simplifie",
    "2024_QoS_Metropole_voix_habitations_clean",
    "2024_QoS_Metropole_voix_transports_clean",
    "2024_QoS_Metropole_data_habitations_clean",
    "2024_QoS_Metropole_data_transports_clean",
    "ITU_FactsFigures2024_summary_clean"
  ),
  lignes = c(
    nrow(arcep_glob),
    nrow(arcep_glob_compl),
    nrow(arcep_glob_simpl),
    nrow(voix_hab),
    nrow(voix_trp),
    nrow(data_hab),
    nrow(data_trp),
    nrow(itu_sum)
  )
)

qa_tbl |>
  gt::gt() |>
  gt::fmt_number(columns = lignes, decimals = 0) |>
  gt::tab_header(title = "Contrôle des entrées – nombre de lignes par fichier")
```

---

## 3. Indicateurs globaux ARCEP – vue synthétique

Cette section exploite les indicateurs agrégés par **service** (Voix, SMS, Web, Data…) et par **opérateur** pour les zones d’habitation.

```{r}
# 3.1. Passage en format long (opérateurs) ----
arcep_glob_long <- tibble::tibble()

if (nrow(arcep_glob) > 0) {
  safe_run({
    arcep_glob_long <<- arcep_glob |>
      dplyr::filter(!is.na(service), !is.na(indicateur)) |>
      tidyr::pivot_longer(
        cols = tidyselect::all_of(c("bouygues","free","orange","sfr")),
        names_to = "operateur",
        values_to = "valeur"
      ) |>
      dplyr::mutate(
        operateur = dplyr::case_when(
          operateur == "bouygues" ~ "Bouygues Telecom",
          operateur == "free"     ~ "Free Mobile",
          operateur == "orange"   ~ "Orange",
          operateur == "sfr"      ~ "SFR",
          TRUE ~ operateur
        )
      )
  })
}
```

### 3.1. Indicateurs les plus représentés

```{r}
safe_run({
  glob_hab <- arcep_glob_long |>
    dplyr::filter(
      lieu_strate == "toutes zones d'habitation",
      situation   == "tous usages"
    )

  if (nrow(glob_hab) > 0) {
    glob_hab |>
      dplyr::count(service, indicateur, sort = TRUE, name = "n_mesures") |>
      dplyr::slice_head(n = 15) |>
      gt::gt() |>
      gt::fmt_number(columns = n_mesures, decimals = 0) |>
      gt::tab_header(title = "Indicateurs les plus représentés (toutes zones d'habitation, tous usages)")
  }
})
```

### 3.2. Voix – communications réussies & qualité perçue

```{r}
safe_run({
  glob_hab <- arcep_glob_long |>
    dplyr::filter(
      lieu_strate == "toutes zones d'habitation",
      situation   == "tous usages",
      service == "voix"
    )

  # Taux de communications réussies
  voix_reussite <- glob_hab |>
    dplyr::filter(stringr::str_detect(indicateur, "communications réussies$"))

  if (nrow(voix_reussite) > 0) {
    voix_reussite |>
      ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
      ggplot2::geom_col(show.legend = FALSE) +
      ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      ggplot2::labs(
        title = "Voix – taux de communications réussies",
        subtitle = "Toutes zones d'habitation, tous usages",
        x = NULL, y = "Taux de communications réussies"
      )
  }

  # Communications sans perturbations audibles
  voix_sans_pert <- glob_hab |>
    dplyr::filter(stringr::str_detect(indicateur, "sans perturbations audibles"))

  if (nrow(voix_sans_pert) > 0) {
    voix_sans_pert |>
      ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
      ggplot2::geom_col(show.legend = FALSE) +
      ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      ggplot2::labs(
        title = "Voix – communications sans perturbations audibles",
        subtitle = "Toutes zones d'habitation, tous usages",
        x = NULL, y = "Taux de communications sans perturbations"
      )
  }
})
```

### 3.3. Web / Data – délais d’accès aux pages

```{r}
safe_run({
  glob_hab <- arcep_glob_long |>
    dplyr::filter(
      lieu_strate == "toutes zones d'habitation",
      situation   == "tous usages",
      service == "web"
    )

  web_10s <- glob_hab |>
    dplyr::filter(stringr::str_detect(indicateur, "10s"))
  web_5s  <- glob_hab |>
    dplyr::filter(stringr::str_detect(indicateur, "5s"))

  if (nrow(web_10s) > 0) {
    web_10s |>
      ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
      ggplot2::geom_col(show.legend = FALSE) +
      ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      ggplot2::labs(
        title    = "Web – accès au site en moins de 10s",
        subtitle = "Toutes zones d'habitation, tous usages",
        x = NULL, y = "Taux de pages chargées < 10s"
      )
  }

  if (nrow(web_5s) > 0) {
    web_5s |>
      ggplot2::ggplot(ggplot2::aes(x = operateur, y = valeur, fill = operateur)) +
      ggplot2::geom_col(show.legend = FALSE) +
      ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      ggplot2::labs(
        title    = "Web – accès au site en moins de 5s",
        subtitle = "Toutes zones d'habitation, tous usages",
        x = NULL, y = "Taux de pages chargées < 5s"
      )
  }
})
```

---

## 4. Voix – analyse détaillée (habitations vs transports)

```{r}
safe_run({
  # Préparation des mesures Voix
  prepare_voix <- function(df, contexte) {
    if (!is.data.frame(df) || nrow(df) == 0) return(tibble::tibble())
    needed <- c("call_type","time_to_call","min_mos","zone","zone_name","operator")
    if (!all(needed %in% names(df))) return(tibble::tibble())

    df |>
      dplyr::mutate(
        contexte = contexte,
        operateur = dplyr::case_when(
          stringr::str_detect(call_type, "Orange")   ~ "Orange",
          stringr::str_detect(call_type, "SFR")      ~ "SFR",
          stringr::str_detect(call_type, "Bouygues") ~ "Bouygues Telecom",
          stringr::str_detect(call_type, "Free")     ~ "Free Mobile",
          TRUE ~ NA_character_
        ),
        time_to_call = suppressWarnings(as.numeric(time_to_call)),
        min_mos      = suppressWarnings(as.numeric(min_mos))
      ) |>
      dplyr::filter(!is.na(operateur))
  }

  voix_hab_prep <- prepare_voix(voix_hab, "Habitations")
  voix_trp_prep <- prepare_voix(voix_trp, "Transports")

  voix_all <- dplyr::bind_rows(voix_hab_prep, voix_trp_prep)

  if (nrow(voix_all) == 0) return(NULL)

  # Indicateurs synthétiques par opérateur
  synth_voix_op <- voix_all |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(
      n_appels       = dplyr::n(),
      pct_ttc_5s     = mean(time_to_call <= 5,  na.rm = TRUE),
      pct_ttc_10s    = mean(time_to_call <= 10, na.rm = TRUE),
      mos_median     = stats::median(min_mos, na.rm = TRUE),
      .groups        = "drop"
    )

  synth_voix_op |>
    gt::gt(rowname_col = "operateur") |>
    gt::fmt_number(columns = n_appels, decimals = 0) |>
    gt::fmt_percent(columns = c(pct_ttc_5s, pct_ttc_10s), decimals = 1) |>
    gt::fmt_number(columns = mos_median, decimals = 2) |>
    gt::tab_header(title = "Voix – indicateurs de performance par opérateur et contexte")

})
```

```{r}
safe_run({
  voix_hab_prep <- prepare_voix(voix_hab, "Habitations")
  voix_trp_prep <- prepare_voix(voix_trp, "Transports")
  voix_all      <- dplyr::bind_rows(voix_hab_prep, voix_trp_prep)

  if (nrow(voix_all) == 0) return(NULL)

  voix_all |>
    dplyr::mutate(ttc_5s = time_to_call <= 5) |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(pct_ttc_5s = mean(ttc_5s, na.rm = TRUE), .groups = "drop") |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = pct_ttc_5s, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::facet_wrap(~contexte) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title = "Voix – part des appels établis en moins de 5 secondes",
      x = NULL, y = "Part des appels (≤ 5s)"
    )
})
```

---

## 5. Data – analyse détaillée (habitations vs transports)

```{r}
safe_run({
  # Préparation Data – habitations
  prepare_data_hab <- function(df) {
    if (!is.data.frame(df) || nrow(df) == 0) return(tibble::tibble())
    needed <- c("operator","zone","zone_name",
                "loaded_in_less_5_secondes","loaded_in_less_10_secondes",
                "quality_correct","quality_perfect","upload_ok")
    if (!all(needed %in% names(df))) return(tibble::tibble())

    df |>
      dplyr::mutate(
        contexte  = "Habitations",
        operateur = dplyr::case_when(
          stringr::str_detect(operator, "Orange")   ~ "Orange",
          stringr::str_detect(operator, "SFR")      ~ "SFR",
          stringr::str_detect(operator, "Bouygues") ~ "Bouygues Telecom",
          stringr::str_detect(operator, "Free")     ~ "Free Mobile",
          TRUE ~ NA_character_
        ),
        loaded_5s  = suppressWarnings(as.numeric(loaded_in_less_5_secondes))  > 0,
        loaded_10s = suppressWarnings(as.numeric(loaded_in_less_10_secondes)) > 0,
        qual_corr  = suppressWarnings(as.numeric(quality_correct))            > 0,
        qual_perf  = suppressWarnings(as.numeric(quality_perfect))            > 0,
        upload_ok_ = suppressWarnings(as.numeric(upload_ok))                  > 0
      ) |>
      dplyr::filter(!is.na(operateur))
  }

  # Préparation Data – transports
  prepare_data_trp <- function(df) {
    if (!is.data.frame(df) || nrow(df) == 0) return(tibble::tibble())
    needed <- c("operator","axis","axis_name",
                "loaded_in_less_5_secondes","loaded_in_less_10_secondes")
    if (!all(needed %in% names(df))) return(tibble::tibble())

    df |>
      dplyr::mutate(
        contexte  = "Transports",
        zone      = axis,
        zone_name = axis_name,
        operateur = dplyr::case_when(
          stringr::str_detect(operator, "Orange")   ~ "Orange",
          stringr::str_detect(operator, "SFR")      ~ "SFR",
          stringr::str_detect(operator, "Bouygues") ~ "Bouygues Telecom",
          stringr::str_detect(operator, "Free")     ~ "Free Mobile",
          TRUE ~ NA_character_
        ),
        loaded_5s  = suppressWarnings(as.numeric(loaded_in_less_5_secondes))  > 0,
        loaded_10s = suppressWarnings(as.numeric(loaded_in_less_10_secondes)) > 0,
        qual_corr  = NA,
        qual_perf  = NA,
        upload_ok_ = NA
      ) |>
      dplyr::filter(!is.na(operateur))
  }

  data_hab_prep <- prepare_data_hab(data_hab)
  data_trp_prep <- prepare_data_trp(data_trp)

  data_all <- dplyr::bind_rows(data_hab_prep, data_trp_prep)

  if (nrow(data_all) == 0) return(NULL)

  # Indicateurs synthétiques par opérateur
  synth_data_op <- data_all |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(
      n_sessions    = dplyr::n(),
      pct_5s        = mean(loaded_5s,  na.rm = TRUE),
      pct_10s       = mean(loaded_10s, na.rm = TRUE),
      pct_qual_corr = mean(qual_corr,  na.rm = TRUE),
      pct_qual_perf = mean(qual_perf,  na.rm = TRUE),
      pct_upload_ok = mean(upload_ok_, na.rm = TRUE),
      .groups       = "drop"
    )

  synth_data_op |>
    gt::gt(rowname_col = "operateur") |>
    gt::fmt_number(columns = n_sessions, decimals = 0) |>
    gt::fmt_percent(
      columns = c(pct_5s, pct_10s, pct_qual_corr, pct_qual_perf, pct_upload_ok),
      decimals = 1
    ) |>
    gt::tab_header(title = "Data – indicateurs de performance par opérateur et contexte")

})
```

```{r}
safe_run({
  data_hab_prep <- prepare_data_hab(data_hab)
  data_trp_prep <- prepare_data_trp(data_trp)
  data_all      <- dplyr::bind_rows(data_hab_prep, data_trp_prep)

  if (nrow(data_all) == 0) return(NULL)

  data_all |>
    dplyr::group_by(contexte, operateur) |>
    dplyr::summarise(pct_5s = mean(loaded_5s, na.rm = TRUE), .groups = "drop") |>
    ggplot2::ggplot(ggplot2::aes(x = operateur, y = pct_5s, fill = operateur)) +
    ggplot2::geom_col(show.legend = FALSE) +
    ggplot2::facet_wrap(~contexte) +
    ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    ggplot2::labs(
      title = "Data – part des pages chargées en moins de 5 secondes",
      x = NULL, y = "Part des sessions (≤ 5s)"
    )
})
```

---

## 6. ITU Facts & Figures 2024 – synthèse des jeux de données

```{r}
safe_run({
  if (nrow(itu_sum) > 0) {
    cols_presentes <- intersect(
      c("sub_dataset","lignes","annees_min","annees_max","pays_regions","zones"),
      names(itu_sum)
    )

    itu_sum |>
      dplyr::select(tidyselect::all_of(cols_presentes)) |>
      gt::gt() |>
      gt::fmt_number(
        columns = tidyselect::any_of(c("lignes","annees_min","annees_max","pays_regions","zones")),
        decimals = 0
      ) |>
      gt::tab_header(title = "ITU Facts & Figures 2024 – synthèse des jeux de données")
  }
})
```

---

## 7. Synthèse et pistes de prolongement

- Les indicateurs globaux ARCEP confirment un **niveau global élevé** de QoS mobile en France, avec des taux de communications réussies et de chargement de pages majoritairement supérieurs à 95 %, tout en montrant des **différences entre opérateurs**.
- Les données détaillées Voix mettent en évidence des **contrastes entre habitations et transports**, notamment sur le temps d’établissement d’appel et la qualité vocale (MOS).
- L’analyse Data souligne le rôle clé de la **latence perçue** (pages ≤ 5 secondes) pour l’expérience utilisateur, avec des zones / axes où la performance reste en retrait.
- Les jeux ITU Facts & Figures 2024 offrent un cadre structuré pour **positionner la France** parmi les autres pays en termes de couverture, d’usage d’Internet et de capacité, ce qui sera exploité dans la suite du projet pour le benchmark international.

Les étapes suivantes pourront inclure :

- la construction d’**indices composites** par axe (Voix, Data, Radio) et par opérateur ;
- la définition de **seuils cibles** et de **KPI de suivi** par type de zone ;
- l’intégration complète des indicateurs ITU et d’autres sources internationales pour un **benchmark France vs UE / OCDE / leaders QoS**.
